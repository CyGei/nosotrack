<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NosoTrack</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,300;0,400;0,600;0,700;0,900;1,300;1,600&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        /* ========== RESET & BASE ========== */
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            font-family: 'Source Sans Pro', sans-serif;
            background: #1b1f22;
            color: #ffffff;
            overflow-x: hidden;
            font-weight: 300;
            line-height: 1.7;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        a { color: inherit; text-decoration: none; }
        img { max-width: 100%; display: block; }

        /* ========== VARIABLES ========== */
        :root {
            --accent: #ff073a;
            --accent-dim: rgba(255, 7, 58, 0.15);
            --accent-glow: rgba(255, 7, 58, 0.4);
            --bg: #1b1f22;
            --bg-card: rgba(255, 255, 255, 0.075);
            --bg-card-hover: rgba(255, 255, 255, 0.12);
            --text-primary: #ffffff;
            --text-secondary: #ecececff;
            --text-dim: #dededeff;
            --border: rgba(255,255,255,0.1);
            --mono: 'JetBrains Mono', monospace;
            --display: 'Source Sans Pro', sans-serif;
            --body: 'Source Sans Pro', sans-serif;
            --container: 1200px;
        }

        /* ========== UTILITIES ========== */
        .container { max-width: var(--container); margin: 0 auto; padding: 0 24px; }
        .section-tag {
            font-family: var(--mono);
            font-size: 0.72rem;
            color: var(--accent);
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 16px;
            display: block;
            font-weight: 400;
        }
        .section-title {
            font-family: var(--display);
            font-weight: 800;
            font-size: clamp(2.2rem, 5vw, 4rem);
            color: var(--text-primary);
            line-height: 1.1;
            margin-bottom: 24px;
            letter-spacing: -0.02em;
        }
        .section-padding { padding: 120px 0; }

        /* ========== SCROLL ANIMATIONS ========== */
        .reveal {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.7s cubic-bezier(0.16, 1, 0.3, 1), transform 0.7s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .reveal.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* ========== NAV ========== */
        nav.main-nav {
            position: fixed; top: 0; left: 0; width: 100%; z-index: 1000;
            background: rgba(19,21,25,0.85);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border-bottom: 1px solid var(--border);
        }
        .nav-inner {
            max-width: var(--container); margin: 0 auto; padding: 0 24px;
            display: flex; align-items: center; justify-content: space-between; height: 64px;
        }
        .nav-logo {
            font-family: var(--display); font-weight: 800; font-size: 1.2rem;
            color: var(--text-primary); letter-spacing: -0.5px;
        }
        .nav-logo span { color: var(--accent); }
        .nav-links {
            display: flex; align-items: center; gap: 28px; list-style: none;
        }
        .nav-links a {
            font-family: var(--mono); font-size: 0.7rem; letter-spacing: 1px;
            text-transform: uppercase; color: var(--text-secondary); transition: color 0.3s;
        }
        .nav-links a:hover { color: var(--text-primary); }
        .nav-cta {
            background: var(--accent); color: #fff !important;
            padding: 8px 20px; border-radius: 6px;
            font-weight: 500; transition: background 0.3s, transform 0.2s;
        }
        .nav-cta:hover { background: #cc052e; transform: translateY(-1px); }
        .nav-hamburger {
            display: none; flex-direction: column; gap: 5px;
            cursor: pointer; background: none; border: none; padding: 4px;
        }
        .nav-hamburger span { width: 22px; height: 1.5px; background: var(--text-primary); transition: transform 0.3s, opacity 0.3s; }

        /* ========== HERO ========== */
        #hero {
            position: relative; min-height: 100vh;
            display: flex; align-items: center; overflow: hidden;
        }
        #network-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
        }
        .hero-content {
            position: relative; z-index: 2;
            max-width: var(--container); margin: 0 auto; padding: 0 24px; padding-top: 100px;
        }
        .hero-eyebrow {
            font-family: var(--mono); font-size: 0.75rem; letter-spacing: 4px;
            text-transform: uppercase; color: var(--accent); margin-bottom: 24px; font-weight: 400;
        }
        .hero-title {
            font-family: var(--display); font-weight: 800;
            font-size: clamp(3rem, 7vw, 6.5rem); line-height: 1.05;
            color: var(--text-primary); margin-bottom: 28px; letter-spacing: -0.03em;
        }
        .hero-title .accent { color: var(--accent); }
        .hero-subtitle {
            font-size: 1.1rem; color: var(--text-secondary);
            max-width: 560px; line-height: 1.8; margin-bottom: 40px;
        }
        .hero-buttons { display: flex; gap: 14px; flex-wrap: wrap; }
        .btn-primary {
            display: inline-flex; align-items: center; gap: 8px;
            background: var(--accent); color: #fff; padding: 12px 28px;
            border-radius: 6px; font-family: var(--mono); font-size: 0.8rem;
            letter-spacing: 1px; text-transform: uppercase;
            transition: background 0.3s, transform 0.2s; border: none; cursor: pointer;
        }
        .btn-primary:hover { background: #cc052e; transform: translateY(-2px); }
        .btn-secondary {
            display: inline-flex; align-items: center; gap: 8px;
            background: transparent; color: var(--text-primary); padding: 12px 28px;
            border-radius: 6px; border: 1px solid rgba(255,255,255,0.12);
            font-family: var(--mono); font-size: 0.8rem; letter-spacing: 1px;
            text-transform: uppercase; transition: border-color 0.3s, transform 0.2s; cursor: pointer;
        }
        .btn-secondary:hover { border-color: var(--accent); transform: translateY(-2px); }

        /* ========== MARQUEE ========== */
        .marquee-section {
            border-top: 1px solid var(--border); border-bottom: 1px solid var(--border);
            padding: 18px 0; overflow: hidden; background: var(--bg);
        }
        .marquee-track {
            display: flex; gap: 56px;
            animation: marquee 30s linear infinite; width: max-content;
        }
        .marquee-track span {
            font-family: var(--mono); font-size: 0.72rem; letter-spacing: 3px;
            text-transform: uppercase; color: var(--text-dim); white-space: nowrap;
        }
        .marquee-track span::after { content: '//'; margin-left: 56px; color: var(--accent); opacity: 0.4; }
        @keyframes marquee { 0% { transform: translateX(0); } 100% { transform: translateX(-50%); } }

        /* ========== ABOUT ========== */
        #about { background: var(--bg); }
        .about-text { max-width: 780px; }
        .about-text p {
            color: var(--text-secondary); margin-bottom: 24px;
            text-align: justify; font-size: 1rem; line-height: 1.8;
        }
        .about-text strong { color: var(--text-primary); font-weight: 500; }
        .about-text em { color: var(--text-secondary); font-style: italic; }
        .nosotrack-noso {
            color: var(--text-primary); font-weight: 700;
            font-family: var(--mono); font-size: 1rem;
        }
        .nosotrack-highlight {
            color: var(--accent); font-weight: 700;
            font-family: var(--mono); font-size: 1rem;
        }

        /* Burden stats within about */
        .about-stats {
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 1px; margin-top: 48px; margin-bottom: 56px;
            background: var(--border); border-radius: 10px; overflow: hidden;
        }
        .about-stat {
            background: var(--bg-card); padding: 36px 28px; text-align: center;
            transition: background 0.3s;
        }
        .about-stat:hover { background: var(--bg-card-hover); }
        .about-stat-label {
            font-family: var(--mono); font-size: 0.65rem; letter-spacing: 3px;
            text-transform: uppercase; color: var(--text-dim); margin-bottom: 10px;
        }
        .about-stat-value {
            font-family: var(--display); font-weight: 800;
            font-size: clamp(2rem, 3.5vw, 2.8rem); color: var(--text-primary);
            line-height: 1; margin-bottom: 6px;
        }
        .about-stat-detail {
            font-family: var(--mono); font-size: 0.6rem; letter-spacing: 2px;
            text-transform: uppercase; color: var(--text-dim);
        }

        /* 3D Network viz container in About */
        #three-container {
            width: 100%; height: 550px; position: relative;
            border: 1px solid var(--border); border-radius: 10px;
            overflow: hidden; background: rgba(0,0,0,0.2);
        }
        #three-container canvas { display: block; }
        .viz-legend {
            position: absolute; top: 16px; left: 16px;
            background: rgba(19,21,25,0.85); backdrop-filter: blur(10px);
            border: 1px solid var(--border); border-radius: 8px;
            padding: 14px 16px; font-family: var(--mono); font-size: 0.65rem;
            letter-spacing: 1px; color: var(--text-secondary); z-index: 10;
        }
        .viz-legend-title {
            font-weight: 500; color: var(--text-dim); font-size: 0.55rem;
            margin-bottom: 6px; letter-spacing: 2px;
        }
        .viz-legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
        .viz-legend-dot { width: 8px; height: 8px; border-radius: 50%; }
        .viz-legend-tri {
            width: 0; height: 0;
            border-left: 4px solid transparent; border-right: 4px solid transparent;
            border-bottom: 7px solid #888;
        }
        .viz-tooltip {
            position: absolute; background: rgba(19,21,25,0.9);
            border: 1px solid var(--accent); border-radius: 6px;
            padding: 8px 12px; font-family: var(--mono); font-size: 0.7rem;
            color: var(--text-primary); pointer-events: none; z-index: 20; display: none;
        }

        /* ========== HOW IT WORKS / PIPELINE ========== */
        #how-it-works { background: var(--bg); position: relative; overflow: hidden; }
        #pipeline-bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; }
        .pipeline-wrap { position: relative; z-index: 1; }
        .pipeline-subtitle {
            color: var(--text-secondary); font-size: 1rem; max-width: 620px;
            margin-bottom: 56px; line-height: 1.8;
        }

        /* 4-Step vertical flow */
        .pipeline-flow {
            display: flex; flex-direction: column; align-items: center;
            gap: 0; max-width: 900px; margin: 0 auto;
        }
        .pipeline-step { width: 100%; position: relative; }
        .pipeline-step-badge { display: flex; align-items: center; gap: 12px; margin-bottom: 14px; }
        .pipeline-step-num {
            width: 30px; height: 30px; border-radius: 50%;
            background: rgba(255,7,58,0.1); border: 1px solid rgba(255,7,58,0.25);
            display: flex; align-items: center; justify-content: center;
            font-family: var(--mono); font-size: 0.65rem; font-weight: 500;
            color: var(--accent); flex-shrink: 0;
        }
        .pipeline-step-label {
            font-family: var(--mono); font-size: 0.58rem;
            letter-spacing: 2px; text-transform: uppercase; color: var(--text-dim);
        }

        .pipeline-sources {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 14px;
        }
        .pipeline-single { width: 100%; }

        /* Connector */
        .pipeline-connector {
            display: flex; align-items: center; justify-content: center;
            flex-direction: column; height: 56px; position: relative; width: 100%;
        }
        .pipeline-connector canvas { width: 100%; height: 100%; display: block; }

        /* Glassmorphism card */
        .p-card {
            position: relative; background: rgba(255,255,255,0.025);
            border: 1px solid rgba(255,255,255,0.05); border-radius: 12px;
            padding: 22px; overflow: hidden;
            transition: border-color 0.4s, transform 0.4s, box-shadow 0.4s;
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        }
        .p-card:hover {
            border-color: rgba(255,7,58,0.2);
            transform: translateY(-2px);
            box-shadow: 0 6px 24px rgba(255,7,58,0.04);
        }
        .p-card-glow {
            position: absolute; top: -40px; right: -40px;
            width: 100px; height: 100px;
            background: radial-gradient(circle, rgba(255,7,58,0.06) 0%, transparent 70%);
            border-radius: 50%; pointer-events: none; opacity: 0; transition: opacity 0.6s;
        }
        .p-card:hover .p-card-glow { opacity: 1; }

        /* Card canvas */
        .p-card-canvas {
            width: 100%; height: 100px; display: block;
            border-radius: 8px; margin-bottom: 14px;
            background: rgba(0,0,0,0.25);
        }

        /* Engine hero card */
        .p-card--engine {
            border-color: rgba(255,7,58,0.12);
            background: rgba(255,7,58,0.015);
        }
        .p-card--engine .p-card-canvas {
            height: 340px;
            border: 1px solid rgba(255,255,255,0.03);
            background: rgba(0,0,0,0.4);
        }
        .engine-features {
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 10px; margin-top: 14px;
        }
        .engine-feat {
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.04);
            border-radius: 8px; padding: 10px 12px;
            font-family: var(--mono); font-size: 0.6rem;
            color: var(--text-secondary); letter-spacing: 0.3px;
        }
        .engine-feat strong {
            display: block; color: var(--text-primary);
            font-family: var(--display); font-size: 0.75rem;
            margin-bottom: 2px; font-weight: 600;
        }

        .p-card-tag {
            font-family: var(--mono); font-size: 0.55rem;
            letter-spacing: 2px; text-transform: uppercase;
            color: var(--accent); margin-bottom: 6px; opacity: 0.8;
        }
        .p-card-title {
            font-family: var(--display); font-weight: 700;
            font-size: 1rem; color: var(--text-primary);
            margin-bottom: 5px; line-height: 1.3;
        }
        .p-card--engine .p-card-title { font-size: 1.25rem; margin-bottom: 8px; }
        .p-card-desc {
            font-size: 0.8rem; color: var(--text-secondary); line-height: 1.7;
        }

        @media (max-width: 768px) {
            .pipeline-sources { grid-template-columns: 1fr; }
            .engine-features { grid-template-columns: 1fr; }
            .p-card-canvas { height: 80px; }
            .p-card--engine .p-card-canvas { height: 240px; }
        }

        /* ========== RESEARCH ========== */
        .research-intro {
            max-width: 700px; color: var(--text-secondary);
            margin-bottom: 48px; font-size: 1rem; text-align: justify; line-height: 1.8;
        }
        .research-sub {
            font-family: var(--mono); font-size: 0.7rem; letter-spacing: 3px;
            text-transform: uppercase; color: var(--text-dim); margin-bottom: 20px;
        }
        .pub-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 14px; }
        .pub-card {
            display: block; background: var(--bg-card);
            border: 1px solid var(--border); border-radius: 10px; padding: 24px;
            transition: border-color 0.3s, transform 0.3s, background 0.3s;
        }
        .pub-card:hover {
            border-color: rgba(255,7,58,0.25); background: var(--bg-card-hover);
            transform: translateY(-2px);
        }
        .pub-tag {
            font-family: var(--mono); font-size: 0.6rem; letter-spacing: 2px;
            text-transform: uppercase; color: var(--accent); background: var(--accent-dim);
            padding: 3px 8px; border-radius: 4px; display: inline-block; margin-bottom: 10px;
        }
        .pub-title {
            font-family: var(--display); font-weight: 700; font-size: 1.05rem;
            color: var(--text-primary); margin-bottom: 6px;
        }
        .pub-desc { color: var(--text-secondary); font-size: 0.85rem; }
        .pub-arrow {
            display: inline-block; margin-top: 10px; color: var(--accent);
            font-size: 0.85rem; transition: transform 0.3s;
        }
        .pub-card:hover .pub-arrow { transform: translateX(4px); }

        /* ========== TEAM ========== */
        #team { background: var(--bg-card); }
        .team-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-top: 48px; }
        .team-card {
            background: var(--bg); border: 1px solid var(--border); border-radius: 10px;
            overflow: hidden; transition: border-color 0.3s, transform 0.3s;
        }
        .team-card:hover { border-color: rgba(255,7,58,0.25); transform: translateY(-3px); }
        .team-photo { width: 100%; aspect-ratio: 1; object-fit: cover; filter: grayscale(30%); transition: filter 0.3s; }
        .team-card:hover .team-photo { filter: grayscale(0%); }
        .team-info { padding: 18px; }
        .team-name { font-family: var(--display); font-weight: 700; font-size: 1rem; color: var(--text-primary); margin-bottom: 3px; }
        .team-role { font-family: var(--mono); font-size: 0.65rem; letter-spacing: 1px; color: var(--accent); margin-bottom: 10px; }
        .team-bio { color: var(--text-secondary); font-size: 0.82rem; line-height: 1.65; }
        .team-bio a { color: var(--accent); text-decoration: underline; text-underline-offset: 2px; }
        .team-bio a:hover { color: var(--text-primary); }

        /* ========== CONTACT ========== */
        #contact .contact-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 80px; align-items: start; }
        .contact-heading {
            font-family: var(--display); font-weight: 800;
            font-size: clamp(2rem, 4vw, 3.2rem); color: var(--text-primary);
            line-height: 1.1; margin-bottom: 20px; letter-spacing: -0.02em;
        }
        .contact-sub { color: var(--text-secondary); font-size: 1rem; margin-bottom: 32px; }
        .contact-form label {
            font-family: var(--mono); font-size: 0.65rem; letter-spacing: 2px;
            text-transform: uppercase; color: var(--text-secondary);
            display: block; margin-bottom: 6px;
        }
        .contact-form input, .contact-form textarea {
            width: 100%; background: var(--bg-card);
            border: 1px solid var(--border); border-radius: 6px;
            padding: 12px 16px; color: var(--text-primary);
            font-family: var(--body); font-size: 0.9rem;
            margin-bottom: 18px; transition: border-color 0.3s; outline: none;
        }
        .contact-form input:focus, .contact-form textarea:focus { border-color: var(--accent); }
        .contact-form textarea { resize: vertical; min-height: 110px; }
        .form-buttons { display: flex; gap: 10px; }

        /* ========== FOOTER ========== */
        footer { border-top: 1px solid var(--border); padding: 40px 0; }
        .footer-inner { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 16px; }
        .footer-logo { font-family: var(--display); font-weight: 800; font-size: 1rem; color: var(--text-primary); }
        .footer-logo span { color: var(--accent); }
        .footer-links { display: flex; gap: 20px; list-style: none; }
        .footer-links a {
            font-family: var(--mono); font-size: 0.65rem; letter-spacing: 1px;
            text-transform: uppercase; color: var(--text-dim); transition: color 0.3s;
        }
        .footer-links a:hover { color: var(--text-primary); }
        .footer-copy { font-size: 0.75rem; color: var(--text-dim); }

        /* ========== RESPONSIVE ========== */
        @media (max-width: 1024px) {
            .contact-grid { grid-template-columns: 1fr; gap: 48px; }
            .team-grid { grid-template-columns: repeat(2, 1fr); }
            #three-container { height: 450px; }
        }
        @media (max-width: 768px) {
            .nav-links { display: none; }
            .nav-links.open {
                display: flex; flex-direction: column; position: fixed;
                top: 64px; left: 0; width: 100%;
                background: rgba(19,21,25,0.98); backdrop-filter: blur(20px);
                padding: 28px 24px; gap: 20px; border-bottom: 1px solid var(--border);
            }
            .nav-hamburger { display: flex; }
            .about-stats { grid-template-columns: 1fr; }
            .pub-grid { grid-template-columns: 1fr; }
            .team-grid { grid-template-columns: 1fr; }
            .hero-title { font-size: clamp(2.5rem, 10vw, 4rem); }
            .section-padding { padding: 80px 0; }
            #three-container { height: 350px; }
        }
    </style>
</head>
<body>

<!-- ========== NAV ========== -->
<nav class="main-nav">
    <div class="nav-inner">
        <a href="#" class="nav-logo"></a>
        <ul class="nav-links" id="navLinks"></ul>
        <button class="nav-hamburger" id="navToggle" aria-label="Toggle navigation">
            <span></span><span></span><span></span>
        </button>
    </div>
</nav>

<!-- ========== HERO ========== -->
<section id="hero">
    <canvas id="network-canvas"></canvas>
    <div class="hero-content">
        <div class="hero-eyebrow"></div>
        <h1 class="hero-title"></h1>
        <p class="hero-subtitle"></p>
        <div class="hero-buttons"></div>
    </div>
</section>

<!-- ========== MARQUEE ========== -->
<div class="marquee-section">
    <div class="marquee-track"></div>
</div>

<!-- ========== ABOUT ========== -->
<section id="about" class="section-padding">
    <div class="container">
        <div class="about-text reveal">
            <span class="section-tag"></span>
            <h2 class="section-title"></h2>

            <!-- Burden stats -->
            <div class="about-stats reveal">
                <div class="about-stat">
                    <div class="about-stat-label"></div>
                    <div class="about-stat-value"></div>
                    <div class="about-stat-detail"></div>
                </div>
                <div class="about-stat">
                    <div class="about-stat-label"></div>
                    <div class="about-stat-value"></div>
                    <div class="about-stat-detail"></div>
                </div>
                <div class="about-stat">
                    <div class="about-stat-label"></div>
                    <div class="about-stat-value"></div>
                    <div class="about-stat-detail"></div>
                </div>
            </div>
        </div>

        <!-- 3D Transmission Network -->
        <div class="reveal">
            <div id="three-container">
                <div class="viz-legend" id="vizLegend"></div>
                <div class="viz-tooltip" id="vizTooltip"></div>
            </div>
        </div>
    </div>
</section>

<!-- ========== HOW IT WORKS ========== -->
<section id="how-it-works" class="section-padding">
    <canvas id="pipeline-bg"></canvas>
    <div class="container pipeline-wrap">
        <span class="section-tag reveal"></span>
        <h2 class="section-title reveal"></h2>
        <p class="pipeline-subtitle reveal"></p>

        <div class="pipeline-flow">

            <!-- STEP 1: Data Inputs -->
            <div class="pipeline-step reveal">
                <div class="pipeline-step-badge">
                    <div class="pipeline-step-num"></div>
                    <div class="pipeline-step-label"></div>
                </div>
                <div class="pipeline-sources">
                    <div class="p-card" data-pipeline="dna">
                        <div class="p-card-glow"></div>
                        <canvas class="p-card-canvas" data-viz="dna"></canvas>
                        <div class="p-card-tag"></div>
                        <div class="p-card-title"></div>
                        <div class="p-card-desc"></div>
                    </div>
                    <div class="p-card" data-pipeline="contact">
                        <div class="p-card-glow"></div>
                        <canvas class="p-card-canvas" data-viz="contact"></canvas>
                        <div class="p-card-tag"></div>
                        <div class="p-card-title"></div>
                        <div class="p-card-desc"></div>
                    </div>
                    <div class="p-card" data-pipeline="ehr">
                        <div class="p-card-glow"></div>
                        <canvas class="p-card-canvas" data-viz="ehr"></canvas>
                        <div class="p-card-tag"></div>
                        <div class="p-card-title"></div>
                        <div class="p-card-desc"></div>
                    </div>
                </div>
            </div>

            <!-- Connector 1-2 -->
            <div class="pipeline-connector reveal"><canvas id="connector-1"></canvas></div>

            <!-- STEP 2: Anonymisation -->
            <div class="pipeline-step reveal">
                <div class="pipeline-step-badge">
                    <div class="pipeline-step-num"></div>
                    <div class="pipeline-step-label"></div>
                </div>
                <div class="pipeline-single">
                    <div class="p-card" data-pipeline="anon">
                        <div class="p-card-glow"></div>
                        <canvas class="p-card-canvas" data-viz="anon"></canvas>
                        <div class="p-card-tag"></div>
                        <div class="p-card-title"></div>
                        <div class="p-card-desc"></div>
                    </div>
                </div>
            </div>

            <!-- Connector 2-3 -->
            <div class="pipeline-connector reveal"><canvas id="connector-2"></canvas></div>

            <!-- STEP 3: NosoTrack Engine -->
            <div class="pipeline-step reveal">
                <div class="pipeline-step-badge">
                    <div class="pipeline-step-num"></div>
                    <div class="pipeline-step-label"></div>
                </div>
                <div class="pipeline-single">
                    <div class="p-card p-card--engine" data-pipeline="engine">
                        <div class="p-card-glow"></div>
                        <canvas class="p-card-canvas" data-viz="engine" id="engine-canvas"></canvas>
                        <div class="p-card-tag"></div>
                        <div class="p-card-title"></div>
                        <div class="p-card-desc"></div>
                    </div>
                </div>
            </div>

            <!-- Connector 3-4 -->
            <div class="pipeline-connector reveal"><canvas id="connector-3"></canvas></div>

            <!-- STEP 4: Early Warning -->
            <div class="pipeline-step reveal">
                <div class="pipeline-step-badge">
                    <div class="pipeline-step-num"></div>
                    <div class="pipeline-step-label"></div>
                </div>
                <div class="pipeline-single">
                    <div class="p-card" data-pipeline="alert">
                        <div class="p-card-glow"></div>
                        <canvas class="p-card-canvas" data-viz="alert"></canvas>
                        <div class="p-card-tag"></div>
                        <div class="p-card-title"></div>
                        <div class="p-card-desc"></div>
                    </div>
                </div>
            </div>

        </div>
    </div>
</section>

<!-- ========== RESEARCH ========== -->
<section id="research" class="section-padding">
    <div class="container">
        <span class="section-tag reveal"></span>
        <h2 class="section-title reveal"></h2>
        <p class="research-intro reveal"></p>

        <h3 class="research-sub reveal" id="researchPublicationsLabel"></h3>
        <div class="pub-grid reveal"></div>

        <h3 class="research-sub reveal" id="researchSoftwareLabel" style="margin-top: 48px;"></h3>
        <div class="pub-grid reveal"></div>
    </div>
</section>

<!-- ========== TEAM ========== -->
<section id="team" class="section-padding">
    <div class="container">
        <span class="section-tag reveal"></span>
        <h2 class="section-title reveal"></h2>
        <div class="team-grid"></div>
    </div>
</section>

<!-- ========== CONTACT ========== -->
<section id="contact" class="section-padding">
    <div class="container">
        <div class="contact-grid">
            <div class="reveal">
                <span class="section-tag"></span>
                <h2 class="contact-heading"></h2>
                <p class="contact-sub"></p>
                <a id="contactGithub" href="#" target="_blank" style="display:inline-flex; align-items:center; gap:8px; color:var(--text-secondary); font-family:var(--mono); font-size:0.75rem; transition:color 0.3s;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
                </a>
            </div>
            <div class="reveal" style="transition-delay: 0.2s;">
                <form class="contact-form" method="POST">
                    <label for="name"></label>
                    <input type="text" name="name" id="name" required>
                    <label for="email"></label>
                    <input type="email" name="email" id="email" required>
                    <label for="message"></label>
                    <textarea name="message" id="message" rows="5" required></textarea>
                    <div class="form-buttons">
                        <button type="submit" id="btnSubmit" class="btn-primary"></button>
                        <button type="reset" id="btnReset" class="btn-secondary"></button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</section>

<!-- ========== FOOTER ========== -->
<footer>
    <div class="container">
        <div class="footer-inner">
            <div class="footer-logo"></div>
            <ul class="footer-links"></ul>
            <div class="footer-copy"></div>
        </div>
    </div>
</footer>

<!-- ========== SCRIPTS ========== -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ==========================================
// BACKGROUND NETWORK ANIMATION (Canvas 2D)
// ==========================================
(function() {
    const canvas = document.getElementById('network-canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    let particles = [];

    const particleCount = 100;
    const connectionDistance = 130;
    const particleSpeed = 0.35;
    const infectionChance = 0.012;
    const recoveryTime = 700;

    function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    class Particle {
        constructor() {
            this.x = Math.random() * width; this.y = Math.random() * height;
            this.vx = (Math.random() - 0.5) * particleSpeed;
            this.vy = (Math.random() - 0.5) * particleSpeed;
            this.size = Math.random() * 1.5 + 0.5;
            this.isInfected = false; this.infectionTimer = 0;
        }
        infect() { if (!this.isInfected) { this.isInfected = true; this.infectionTimer = recoveryTime; } }
        update() {
            this.x += this.vx; this.y += this.vy;
            if (this.x < 0 || this.x > width) this.vx *= -1;
            if (this.y < 0 || this.y > height) this.vy *= -1;
            if (this.isInfected) { this.infectionTimer--; if (this.infectionTimer <= 0) this.isInfected = false; }
        }
        draw() {
            ctx.fillStyle = this.isInfected ? 'rgba(255, 7, 58, 0.7)' : 'rgba(150, 150, 150, 0.3)';
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            if (this.isInfected) {
                ctx.fillStyle = 'rgba(255, 7, 58, 0.12)';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size + 4, 0, Math.PI * 2); ctx.fill();
            }
        }
    }

    function initParticles() {
        particles = [];
        for (let i = 0; i < particleCount; i++) { const p = new Particle(); if (Math.random() < 0.04) p.infect(); particles.push(p); }
    }
    initParticles();

    function animate() {
        ctx.clearRect(0, 0, width, height);
        if (!particles.some(p => p.isInfected)) particles[Math.floor(Math.random() * particles.length)].infect();
        for (let i = 0; i < particles.length; i++) {
            particles[i].update(); particles[i].draw();
            for (let j = i + 1; j < particles.length; j++) {
                const dx = particles[i].x - particles[j].x, dy = particles[i].y - particles[j].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < connectionDistance) {
                    if (particles[i].isInfected && !particles[j].isInfected && Math.random() < infectionChance) particles[j].infect();
                    else if (!particles[i].isInfected && particles[j].isInfected && Math.random() < infectionChance) particles[i].infect();
                    const opacity = 1 - (dist / connectionDistance);
                    ctx.strokeStyle = (particles[i].isInfected || particles[j].isInfected) ? `rgba(255, 7, 58, ${opacity * 0.35})` : `rgba(150, 150, 150, ${opacity * 0.1})`;
                    ctx.lineWidth = 0.5;
                    ctx.beginPath(); ctx.moveTo(particles[i].x, particles[i].y); ctx.lineTo(particles[j].x, particles[j].y); ctx.stroke();
                }
            }
        }
        requestAnimationFrame(animate);
    }
    animate();
})();

// ==========================================
// NAV TOGGLE
// ==========================================
document.getElementById('navToggle').addEventListener('click', function() { document.getElementById('navLinks').classList.toggle('open'); });
document.querySelectorAll('.nav-links a').forEach(a => { a.addEventListener('click', () => document.getElementById('navLinks').classList.remove('open')); });

// ==========================================
// SCROLL REVEAL
// ==========================================
const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => { if (entry.isIntersecting) entry.target.classList.add('visible'); });
}, { threshold: 0.08, rootMargin: '0px 0px -30px 0px' });
document.querySelectorAll('.reveal').forEach(el => observer.observe(el));
window.__revealObserver = observer;

// ==========================================
// PIPELINE — 4-step flow with mini-canvas
// animations, engine transmission tree viz,
// background particles + connectors
// ==========================================
(function() {
    const ACCENT = '#ff073a';
    const ACTIVE = '#f0f0f0';
    const MONO = '"JetBrains Mono", monospace';
    let frame = 0;

    function initCanvas(c) {
        if (!c) return null;
        const dpr = Math.min(window.devicePixelRatio, 2);
        const r = c.getBoundingClientRect();
        c.width = r.width * dpr; c.height = r.height * dpr;
        const ctx = c.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        return { ctx, w: r.width, h: r.height };
    }

    // Background
    const bgCanvas = document.getElementById('pipeline-bg');
    let bgCtx, bgW, bgH;
    const bgParticles = [];
    function initBg() {
        if (!bgCanvas) return;
        const dpr = Math.min(window.devicePixelRatio, 2);
        const section = bgCanvas.parentElement;
        bgW = section.clientWidth; bgH = section.clientHeight;
        bgCanvas.width = bgW * dpr; bgCanvas.height = bgH * dpr;
        bgCtx = bgCanvas.getContext('2d'); bgCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        bgParticles.length = 0;
        for (let i = 0; i < 35; i++) {
            bgParticles.push({ x: Math.random() * bgW, y: Math.random() * bgH, vy: 0.12 + Math.random() * 0.25, size: Math.random() * 1 + 0.3, opacity: Math.random() * 0.12 + 0.02 });
        }
    }
    function drawBg() {
        if (!bgCtx) return;
        bgCtx.clearRect(0, 0, bgW, bgH);
        bgParticles.forEach(p => {
            p.y += p.vy; if (p.y > bgH + 4) { p.y = -4; p.x = Math.random() * bgW; }
            bgCtx.fillStyle = `rgba(255,7,58,${p.opacity})`;
            bgCtx.beginPath(); bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2); bgCtx.fill();
        });
    }

    // 3 Connectors
    function makeConnector(c, count) {
        const info = initCanvas(c); if (!info) return null;
        const { ctx, w, h } = info;
        const particles = [];
        for (let i = 0; i < count; i++) particles.push({ x: w * (0.35 + Math.random() * 0.3), y: Math.random() * h, vy: 0.3 + Math.random() * 0.4, size: Math.random() * 1.5 + 0.5, phase: Math.random() * Math.PI * 2 });
        return { ctx, w, h, particles, el: c };
    }
    const connectors = [];
    for (let i = 1; i <= 3; i++) { const c = makeConnector(document.getElementById('connector-' + i), 7); if (c) connectors.push(c); }

    function animateConnector(c) {
        if (!c) return;
        c.ctx.clearRect(0, 0, c.w, c.h);
        c.ctx.strokeStyle = 'rgba(255,255,255,0.03)'; c.ctx.lineWidth = 1; c.ctx.setLineDash([2, 6]);
        c.ctx.beginPath(); c.ctx.moveTo(c.w / 2, 0); c.ctx.lineTo(c.w / 2, c.h); c.ctx.stroke();
        c.ctx.setLineDash([]);
        c.particles.forEach(p => {
            p.y += p.vy; p.x += Math.sin(frame * 0.02 + p.phase) * 0.25;
            if (p.y > c.h + 4) { p.y = -4; p.x = c.w * (0.4 + Math.random() * 0.2); }
            const grad = c.ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3.5);
            grad.addColorStop(0, 'rgba(255,7,58,0.5)'); grad.addColorStop(1, 'transparent');
            c.ctx.fillStyle = grad;
            c.ctx.beginPath(); c.ctx.arc(p.x, p.y, p.size * 3.5, 0, Math.PI * 2); c.ctx.fill();
            c.ctx.fillStyle = '#fff';
            c.ctx.beginPath(); c.ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2); c.ctx.fill();
        });
    }

    // Mini-canvas animations (2D)
    const vizCanvases = {};
    document.querySelectorAll('.p-card-canvas[data-viz]').forEach(c => {
        if (c.dataset.viz === 'engine') return;
        const info = initCanvas(c);
        if (info) vizCanvases[c.dataset.viz] = { el: c, ...info };
    });

    // DNA helix
    function vizDNA() {
        const v = vizCanvases.dna; if (!v) return;
        const { ctx, w, h } = v; ctx.clearRect(0, 0, w, h);
        const cx = w / 2, cy = h / 2, amp = 26, len = h * 0.8;
        for (let strand = -1; strand <= 1; strand += 2) {
            ctx.strokeStyle = strand === 1 ? ACCENT : ACTIVE;
            ctx.lineWidth = 1.5; ctx.globalAlpha = strand === 1 ? 0.7 : 0.3;
            ctx.beginPath();
            for (let i = 0; i <= 40; i++) { const t = i / 40; const y = cy - len/2 + t * len; const x = cx + Math.sin(t * Math.PI * 3 + frame * 0.025) * amp * strand; i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y); }
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        const baseCols = ['#5b9bd5','#70ad47','#ff073a','#ffc000'];
        for (let i = 0; i < 7; i++) { const t = (i + 0.3) / 7; const y = cy - len/2 + t * len; const off = Math.sin(t * Math.PI * 3 + frame * 0.025) * amp; ctx.strokeStyle = baseCols[i % 4]; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.4; ctx.beginPath(); ctx.moveTo(cx + off, y); ctx.lineTo(cx - off, y); ctx.stroke(); }
        ctx.globalAlpha = 1;
        const scanY = cy - len/2 + ((frame * 1.2) % len);
        ctx.strokeStyle = ACCENT; ctx.lineWidth = 1; ctx.globalAlpha = 0.3;
        ctx.beginPath(); ctx.moveTo(cx - amp - 8, scanY); ctx.lineTo(cx + amp + 8, scanY); ctx.stroke(); ctx.globalAlpha = 1;
    }

    // Contact network
    function vizContact() {
        const v = vizCanvases.contact; if (!v) return;
        const { ctx, w, h } = v; ctx.clearRect(0, 0, w, h);
        const cx = w/2, cy = h/2;
        const nodes = [ {x:cx,y:cy,r:5,staff:true}, {x:cx-45,y:cy-22,r:3.5}, {x:cx+50,y:cy-18,r:3.5}, {x:cx-35,y:cy+26,r:3.5}, {x:cx+40,y:cy+24,r:3.5}, {x:cx-8,y:cy-34,r:3}, {x:cx+12,y:cy+36,r:3} ];
        const edges = [[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[1,5],[2,4],[3,6]];
        edges.forEach(([a,b]) => { ctx.strokeStyle = 'rgba(255,255,255,0.07)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(nodes[a].x, nodes[a].y); ctx.lineTo(nodes[b].x, nodes[b].y); ctx.stroke(); });
        nodes.forEach((n, i) => {
            const maxPhase = n.staff ? 30 : 22;
            const waveColor = n.staff ? ACCENT : 'rgba(255,255,255,0.35)';
            for (let ring = 0; ring < 2; ring++) {
                const phase = (frame * 0.5 + i * 13 + ring * 15) % maxPhase;
                const pulseR = n.r + 5 + phase;
                ctx.strokeStyle = waveColor; ctx.lineWidth = 1; ctx.globalAlpha = 0.3 * (1 - phase / maxPhase);
                ctx.beginPath(); ctx.arc(n.x, n.y, pulseR, 0, Math.PI * 2); ctx.stroke();
            }
        });
        ctx.globalAlpha = 1;
        nodes.forEach(n => { ctx.fillStyle = n.staff ? ACCENT : 'rgba(255,255,255,0.45)'; ctx.beginPath(); ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2); ctx.fill(); });
    }

    // EHR scrolling
    function vizEHR() {
        const v = vizCanvases.ehr; if (!v) return;
        const { ctx, w, h } = v; ctx.clearRect(0, 0, w, h);
        const rowH = 16, cols = [w*0.08, w*0.28, w*0.55, w*0.78], scrollY = (frame * 0.35) % (rowH * 8);
        ctx.save(); ctx.beginPath(); ctx.rect(0, 0, w, h); ctx.clip();
        for (let r = -1; r < 8; r++) {
            const y = r * rowH - scrollY + h/2; if (y < -rowH || y > h + rowH) continue;
            const rowAlpha = 1 - Math.abs(y - h/2) / (h * 0.6);
            ctx.globalAlpha = Math.max(0.04, Math.min(0.45, rowAlpha));
            if (r === 0) { ctx.font = `500 7px ${MONO}`; ctx.fillStyle = ACCENT; ['ID','WARD','DATE','STATUS'].forEach((t,i) => { ctx.textAlign = 'left'; ctx.fillText(t, cols[i], y); }); }
            else { ctx.font = `300 7px ${MONO}`; ctx.fillStyle = '#666'; const ids = ['P001','P002','S003','P004','S005','P006','P007'], wards = ['A','B','C','A','B','C','A'], stati = ['POS','NEG','POS','NEG','POS','NEG','POS']; const ri = ((r-1)+Math.floor(frame*0.01))%7; ctx.textAlign = 'left'; ctx.fillText(ids[ri], cols[0], y); ctx.fillText(wards[ri], cols[1], y); ctx.fillText('2025-0'+(ri+1), cols[2], y); ctx.fillStyle = stati[ri] === 'POS' ? ACCENT : '#555'; ctx.fillText(stati[ri], cols[3], y); }
        }
        ctx.restore(); ctx.globalAlpha = 1;
        const fadeH = 18; let gradTop = ctx.createLinearGradient(0,0,0,fadeH); gradTop.addColorStop(0,'rgba(0,0,0,0.7)'); gradTop.addColorStop(1,'transparent'); ctx.fillStyle = gradTop; ctx.fillRect(0,0,w,fadeH);
        let gradBot = ctx.createLinearGradient(0,h-fadeH,0,h); gradBot.addColorStop(0,'transparent'); gradBot.addColorStop(1,'rgba(0,0,0,0.7)'); ctx.fillStyle = gradBot; ctx.fillRect(0,h-fadeH,w,fadeH);
    }

    // Anonymisation
    function vizAnon() {
        const v = vizCanvases.anon; if (!v) return;
        const { ctx, w, h } = v; ctx.clearRect(0, 0, w, h);

        // Full cycle: 0-60% transform rows one by one, 60-85% hold, 85-100% fade out
        const cycle = (frame * 0.007) % 1;
        const TRANSFORM_END = 0.60, HOLD_END = 0.85;
        const globalFade = cycle > HOLD_END ? 1 - (cycle - HOLD_END) / (1 - HOLD_END) : 1;

        const fields = [
            { raw: 'Smith, John',   anon: 'ID_7f3a9b'                        },
            { raw: 'DOB 1985-03',   anon: '****-**'                           },
            { raw: 'MRN 47291',     anon: 'REF \u2588\u2588\u2588\u2588\u2588' },
            { raw: 'Room 14-B',     anon: 'LOC_\u2588\u2588\u2588'            },
            { raw: 'Ward: B',       anon: 'Zone: B'                           },
            { raw: 'Nurse: Evans',  anon: 'STAFF_A3'                          },
            { raw: 'PCR+',          anon: 'CASE_POS'                          },
        ];
        const nRows = fields.length;
        const headerH = 13, statusH = 8, topPad = 2;
        const rowH = Math.floor((h - headerH - statusH - topPad) / nRows);
        const tableH = nRows * rowH;
        const topY = topPad;
        const headerY = topY + headerH - 3;
        const startY = topY + headerH + 1;
        const midX = w / 2;
        const leftX = 8, rightX = midX + 8;

        // Column labels
        ctx.font = `400 5.5px ${MONO}`; ctx.textAlign = 'left';
        ctx.fillStyle = `rgba(255,255,255,${0.22 * globalFade})`;
        ctx.fillText('IDENTIFIABLE', leftX, headerY);
        ctx.fillStyle = `rgba(120,255,120,${0.28 * globalFade})`;
        ctx.fillText('ANONYMISED', rightX, headerY);

        // Centre divider
        ctx.strokeStyle = `rgba(255,7,58,${0.15 * globalFade})`; ctx.lineWidth = 1;
        ctx.setLineDash([2, 4]);
        ctx.beginPath(); ctx.moveTo(midX, topY + 2); ctx.lineTo(midX, topY + headerH + tableH); ctx.stroke();
        ctx.setLineDash([]);

        fields.forEach((f, i) => {
            const y = startY + i * rowH;
            // Each row transforms in a 0.14-wide window, staggered across TRANSFORM_END
            const rowStart = (i / nRows) * TRANSFORM_END;
            const t = Math.max(0, Math.min(1, (cycle - rowStart) / 0.14));

            // Left: raw text — clear before transform, dim after
            const rawAlpha = t < 0.5 ? 0.38 : Math.max(0.06, 0.38 - (t - 0.5) * 0.64);
            ctx.font = `300 7px ${MONO}`; ctx.textAlign = 'left';
            ctx.fillStyle = `rgba(255,255,255,${rawAlpha * globalFade})`;
            ctx.fillText(f.raw, leftX, y);

            // Red redaction bar sweeping over raw text
            if (t > 0.2) {
                const barT = Math.min(1, (t - 0.2) / 0.4);
                const fullW = ctx.measureText(f.raw).width;
                ctx.fillStyle = `rgba(255,7,58,${barT * 0.25 * globalFade})`;
                ctx.fillRect(leftX - 1, y - 8, fullW * barT + 2, 10);
            }

            // Centre: arrow pulses during the transform window
            if (t > 0.15 && t < 0.9) {
                const arrowAlpha = Math.sin(((t - 0.15) / 0.75) * Math.PI) * 0.45;
                ctx.font = `400 7px ${MONO}`; ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(255,7,58,${arrowAlpha * globalFade})`;
                ctx.fillText('\u2192', midX, y);
            }

            // Right: anonymised value fades in after redaction starts
            const anonAlpha = t > 0.45 ? Math.min(0.55, (t - 0.45) / 0.4) : 0;
            ctx.font = `300 7px ${MONO}`; ctx.textAlign = 'left';
            ctx.fillStyle = `rgba(120,255,120,${anonAlpha * globalFade})`;
            ctx.fillText(f.anon, rightX, y);
        });

        // Status label
        const statusY = topY + headerH + tableH + 6;
        ctx.font = `400 5.5px ${MONO}`; ctx.textAlign = 'left';
        if (cycle < TRANSFORM_END) {
            ctx.fillStyle = `rgba(255,7,58,${(0.3 + Math.sin(frame * 0.06) * 0.08) * globalFade})`;
            ctx.fillText('ANONYMISING...', leftX, statusY);
        } else if (cycle < HOLD_END) {
            ctx.fillStyle = `rgba(120,255,120,${0.35 * globalFade})`;
            ctx.fillText('GDPR COMPLIANT \u2713', leftX, statusY);
        }
    }

    // Alert dispatch
    function vizAlert() {
        const v = vizCanvases.alert; if (!v) return;
        const { ctx, w, h } = v; ctx.clearRect(0, 0, w, h);
        const cx = w/2, cy = h/2, ew = 32, eh = 22;
        ctx.strokeStyle = ACTIVE; ctx.lineWidth = 1.2; ctx.globalAlpha = 0.35;
        ctx.strokeRect(cx-ew/2, cy-eh/2, ew, eh);
        ctx.beginPath(); ctx.moveTo(cx-ew/2, cy-eh/2); ctx.lineTo(cx, cy+2); ctx.lineTo(cx+ew/2, cy-eh/2); ctx.stroke();
        ctx.globalAlpha = 1;
        const pulse = 0.7 + Math.sin(frame * 0.08) * 0.3;
        ctx.fillStyle = ACCENT; ctx.globalAlpha = pulse;
        ctx.beginPath(); ctx.arc(cx+ew/2+2, cy-eh/2-2, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.globalAlpha = 1; ctx.font = `500 6px ${MONO}`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('!', cx+ew/2+2, cy-eh/2-2); ctx.textBaseline = 'alphabetic';
        for (let i = 0; i < 3; i++) { const r = 26 + ((frame*0.35 + i*16)%45); const alpha = Math.max(0, 0.18 - (r-26)/60); ctx.strokeStyle = ACCENT; ctx.lineWidth = 1; ctx.globalAlpha = alpha; ctx.beginPath(); ctx.arc(cx, cy-4, r, -0.7, 0.7); ctx.stroke(); }
        ctx.globalAlpha = 1;
        const targets = [{x:cx+60,y:cy-18,label:'IPC Team'},{x:cx+55,y:cy+20,label:'Dashboard'},{x:cx-60,y:cy,label:'Hospital'}];
        targets.forEach((tgt, ti) => {
            ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1; ctx.setLineDash([2,3]);
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(tgt.x, tgt.y); ctx.stroke(); ctx.setLineDash([]);
            ctx.fillStyle = 'rgba(255,255,255,0.18)'; ctx.font = `300 6px ${MONO}`; ctx.textAlign = 'center'; ctx.fillText(tgt.label, tgt.x, tgt.y + 10);
            const t = ((frame * 0.01) + ti * 0.3) % 1;
            ctx.fillStyle = ACCENT; ctx.globalAlpha = 1 - t * 0.5;
            ctx.beginPath(); ctx.arc(cx + (tgt.x-cx)*t, cy + (tgt.y-cy)*t, 1.8, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
        });
    }

    // ═══════════════════════════════════════════
    // ENGINE — Transmission tree with infection
    // propagation animation (Canvas 2D)
    // ═══════════════════════════════════════════
    const engineCanvas = document.getElementById('engine-canvas');
    let engineCtx, engineW, engineH;
    const ENGINE_NODES = [];
    const ENGINE_EDGES = [];
    let enginePhase = 0; // 0=building, 1=computing, 2=infecting
    let engineTimer = 0;
    const ENGINE_CYCLE = 900; // total frames per cycle
    const WARD_COLORS = { A: 'rgba(100,150,255,0.8)', B: 'rgba(255,150,100,0.8)', C: 'rgba(150,255,100,0.8)' };

    function initEngineViz() {
        if (!engineCanvas) return;
        const info = initCanvas(engineCanvas);
        if (!info) return;
        engineCtx = info.ctx; engineW = info.w; engineH = info.h;

        // Build transmission tree structure
        ENGINE_NODES.length = 0; ENGINE_EDGES.length = 0;
        const cx = engineW / 2, topY = 40;
        const levelH = Math.min(55, (engineH - 80) / 4);

        // Tree layout: P0 → S1, S2 → P3,P4,P5,P6 → S3 → P7,P8,P9 etc
        const tree = [
            { id: 0, label: 'P0', x: cx, y: topY, ward: 'A', type: 'patient' },
            { id: 1, label: 'S1', x: cx - 120, y: topY + levelH, ward: 'A', type: 'staff' },
            { id: 2, label: 'S2', x: cx + 120, y: topY + levelH, ward: 'B', type: 'staff' },
            { id: 3, label: 'P3', x: cx - 180, y: topY + levelH * 2, ward: 'A', type: 'patient' },
            { id: 4, label: 'P4', x: cx - 80, y: topY + levelH * 2, ward: 'A', type: 'patient' },
            { id: 5, label: 'P5', x: cx + 60, y: topY + levelH * 2, ward: 'B', type: 'patient' },
            { id: 6, label: 'P6', x: cx + 160, y: topY + levelH * 2, ward: 'B', type: 'patient' },
            { id: 7, label: 'S3', x: cx + 60, y: topY + levelH * 3, ward: 'B', type: 'staff' },
            { id: 8, label: 'P7', x: cx - 30, y: topY + levelH * 4, ward: 'C', type: 'patient' },
            { id: 9, label: 'P8', x: cx + 60, y: topY + levelH * 4, ward: 'C', type: 'patient' },
            { id: 10, label: 'P9', x: cx + 150, y: topY + levelH * 4, ward: 'B', type: 'patient' },
        ];
        tree.forEach(n => ENGINE_NODES.push({ ...n, infected: false, infectionTime: -1, r: n.type === 'staff' ? 5 : 6, glowAlpha: 0 }));

        const edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6],[5,7],[7,8],[7,9],[6,10]];
        edges.forEach(([from, to], i) => ENGINE_EDGES.push({ from, to, progress: 0, infectionProgress: 0, order: i }));
    }

    function drawEngineViz() {
        if (!engineCtx) return;
        const ctx = engineCtx, w = engineW, h = engineH;
        ctx.clearRect(0, 0, w, h);

        engineTimer = (engineTimer + 1) % ENGINE_CYCLE;
        const cycleFrac = engineTimer / ENGINE_CYCLE;

        // Phase 0: tree structure appears (0-15%)
        // Phase 1: computing pulse (15-25%)
        // Phase 2: infection propagates (25-90%)
        // Phase 3: hold + fade (90-100%)

        const buildEnd = 0.15;
        const computeEnd = 0.25;
        const infectEnd = 0.88;

        // Background grid
        ctx.strokeStyle = 'rgba(255,255,255,0.015)'; ctx.lineWidth = 0.5;
        for (let x = 0; x < w; x += 30) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
        for (let y = 0; y < h; y += 30) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }

        // Draw edges
        ENGINE_EDGES.forEach((e, i) => {
            const from = ENGINE_NODES[e.from], to = ENGINE_NODES[e.to];

            // Tree building phase
            let edgeBuild = 0;
            if (cycleFrac < buildEnd) {
                edgeBuild = Math.max(0, Math.min(1, (cycleFrac / buildEnd) * ENGINE_EDGES.length - i));
            } else {
                edgeBuild = 1;
            }
            if (edgeBuild <= 0) return;

            const ex = from.x + (to.x - from.x) * edgeBuild;
            const ey = from.y + (to.y - from.y) * edgeBuild;

            // Base edge (lighter grey for better visibility)
            ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(ex, ey); ctx.stroke();

            // Infection propagation along edge
            if (cycleFrac > computeEnd && cycleFrac < infectEnd) {
                const infectFrac = (cycleFrac - computeEnd) / (infectEnd - computeEnd);
                const edgeInfectStart = i / ENGINE_EDGES.length;
                const edgeInfectDuration = 0.15;
                const edgeProgress = Math.max(0, Math.min(1, (infectFrac - edgeInfectStart) / edgeInfectDuration));

                if (edgeProgress > 0 && ENGINE_NODES[e.from].infected) {
                    const dx = to.x - from.x, dy = to.y - from.y;
                    const edgeLen = Math.sqrt(dx*dx + dy*dy);
                    const nx = -dy/edgeLen, ny = dx/edgeLen; // perpendicular

                    // Infected portion of edge — glowing red
                    const ix = from.x + dx * edgeProgress;
                    const iy = from.y + dy * edgeProgress;
                    ctx.strokeStyle = ACCENT; ctx.lineWidth = 2; ctx.globalAlpha = 0.6;
                    ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(ix, iy); ctx.stroke();
                    ctx.globalAlpha = 1;

                    // Particle swarm traveling along edge
                    const particleCount = 12;
                    for (let pi = 0; pi < particleCount; pi++) {
                        const seed = i * 100 + pi * 7.3;
                        const pDelay = pi * 0.03;
                        const pProgress = Math.max(0, Math.min(1, (edgeProgress - pDelay) * 1.2));
                        if (pProgress <= 0) continue;
                        const px = from.x + dx * pProgress;
                        const py = from.y + dy * pProgress;
                        // Perpendicular drift with sine variation
                        const drift = Math.sin(pProgress * Math.PI * 3 + seed) * (4 + (seed % 3));
                        const fx = px + nx * drift;
                        const fy = py + ny * drift;
                        // Fade: bright in middle, fade at edges
                        const fadeIn = Math.min(1, pProgress * 5);
                        const fadeOut = pProgress > 0.7 ? 1 - (pProgress - 0.7) / 0.3 : 1;
                        const alpha = 0.4 * fadeIn * fadeOut + Math.sin(engineTimer * 0.12 + seed) * 0.1;
                        const size = 0.8 + (seed % 3) * 0.4;
                        ctx.fillStyle = ACCENT; ctx.globalAlpha = Math.max(0, alpha);
                        ctx.beginPath(); ctx.arc(fx, fy, size, 0, Math.PI * 2); ctx.fill();
                    }

                    // Soft leading glow
                    const leadGrad = ctx.createRadialGradient(ix, iy, 0, ix, iy, 8);
                    leadGrad.addColorStop(0, 'rgba(255,7,58,0.35)'); leadGrad.addColorStop(1, 'transparent');
                    ctx.globalAlpha = 1; ctx.fillStyle = leadGrad;
                    ctx.beginPath(); ctx.arc(ix, iy, 8, 0, Math.PI * 2); ctx.fill();

                    // Mark target as infected when complete
                    if (edgeProgress >= 1 && !ENGINE_NODES[e.to].infected) {
                        ENGINE_NODES[e.to].infected = true;
                        ENGINE_NODES[e.to].infectionTime = engineTimer;
                    }

                    // Full infected edge glow
                    if (edgeProgress >= 1) {
                        ctx.strokeStyle = ACCENT; ctx.lineWidth = 2; ctx.globalAlpha = 0.4;
                        ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(to.x, to.y); ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                }
            }
        });

        // Draw nodes
        ENGINE_NODES.forEach((n, i) => {
            let nodeBuild = 0;
            if (cycleFrac < buildEnd) {
                nodeBuild = Math.max(0, Math.min(1, (cycleFrac / buildEnd) * (ENGINE_NODES.length + 2) - i));
            } else {
                nodeBuild = 1;
            }
            if (nodeBuild <= 0) return;

            const r = n.r * nodeBuild;

            // Infect P0 at start of infection phase
            if (i === 0 && cycleFrac > computeEnd && !n.infected) {
                n.infected = true;
                n.infectionTime = engineTimer;
            }

            // Node glow for infected
            if (n.infected) {
                const timeSince = engineTimer - n.infectionTime;
                const glowPulse = 0.15 + Math.sin(timeSince * 0.08) * 0.08;
                ctx.fillStyle = `rgba(255,7,58,${glowPulse})`;
                ctx.beginPath(); ctx.arc(n.x, n.y, r * 3, 0, Math.PI * 2); ctx.fill();
            }

            // Ward color ring
            ctx.strokeStyle = WARD_COLORS[n.ward]; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.5;
            ctx.beginPath(); ctx.arc(n.x, n.y, r + 3, 0, Math.PI * 2); ctx.stroke();
            ctx.globalAlpha = 1;

            // Node body
            if (n.type === 'staff') {
                // Diamond shape for staff
                ctx.fillStyle = n.infected ? ACCENT : 'rgba(200,200,200,0.7)';
                ctx.beginPath();
                ctx.moveTo(n.x, n.y - r); ctx.lineTo(n.x + r, n.y);
                ctx.lineTo(n.x, n.y + r); ctx.lineTo(n.x - r, n.y);
                ctx.closePath(); ctx.fill();
            } else {
                // Circle for patients
                ctx.fillStyle = n.infected ? ACCENT : 'rgba(200,200,200,0.6)';
                ctx.beginPath(); ctx.arc(n.x, n.y, r, 0, Math.PI * 2); ctx.fill();
            }

            // Label
            ctx.fillStyle = n.infected ? '#fff' : 'rgba(255,255,255,0.55)';
            ctx.font = `400 7px ${MONO}`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(n.label, n.x, n.y); ctx.textBaseline = 'alphabetic';
        });

        // Computing phase — scanning beam
        if (cycleFrac > buildEnd && cycleFrac < computeEnd) {
            const computeFrac = (cycleFrac - buildEnd) / (computeEnd - buildEnd);
            const scanX = w * computeFrac;
            ctx.strokeStyle = ACCENT; ctx.lineWidth = 1; ctx.globalAlpha = 0.4;
            ctx.beginPath(); ctx.moveTo(scanX, 0); ctx.lineTo(scanX, h); ctx.stroke();
            // Scan glow
            const scanGrad = ctx.createLinearGradient(scanX - 40, 0, scanX, 0);
            scanGrad.addColorStop(0, 'transparent'); scanGrad.addColorStop(1, 'rgba(255,7,58,0.08)');
            ctx.fillStyle = scanGrad; ctx.fillRect(scanX - 40, 0, 40, h);
            ctx.globalAlpha = 1;
            // Status text
            ctx.fillStyle = ACCENT; ctx.globalAlpha = 0.5;
            ctx.font = `400 9px ${MONO}`; ctx.textAlign = 'left';
            ctx.fillText('COMPUTING TRANSMISSION PROBABILITIES...', 12, h - 12);
            ctx.globalAlpha = 1;
        }

        // Infection phase status
        if (cycleFrac > computeEnd && cycleFrac < infectEnd) {
            ctx.fillStyle = ACCENT; ctx.globalAlpha = 0.4 + Math.sin(frame * 0.08) * 0.1;
            ctx.font = `400 9px ${MONO}`; ctx.textAlign = 'left';
            ctx.fillText('RECONSTRUCTING TRANSMISSION TREE...', 12, h - 12);
            ctx.globalAlpha = 1;
        }

        // Hold phase — all infected, display result
        if (cycleFrac > infectEnd) {
            ctx.fillStyle = 'rgba(100,255,100,0.4)';
            ctx.font = `500 9px ${MONO}`; ctx.textAlign = 'left';
            ctx.fillText('TRANSMISSION TREE COMPLETE', 12, h - 12);
        }

        // Reset at cycle end
        if (engineTimer === ENGINE_CYCLE - 1) {
            ENGINE_NODES.forEach(n => { n.infected = false; n.infectionTime = -1; });
        }

        // ── Virus logo (upper-left corner of engine canvas) ──
        const logoCx = 38, logoCy = 34;
        const rotation = frame * 0.006;
        const coreR = 12;
        const spikeCount = 10;
        const spikeLen = 9;
        const bulbR = 2.5;

        ctx.save();
        ctx.translate(logoCx, logoCy);
        ctx.rotate(rotation);

        // Outer subtle glow
        const outerGlow = ctx.createRadialGradient(0, 0, coreR + spikeLen, 0, 0, coreR + spikeLen + 8);
        outerGlow.addColorStop(0, 'rgba(255,7,58,0.06)');
        outerGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = outerGlow;
        ctx.beginPath(); ctx.arc(0, 0, coreR + spikeLen + 8, 0, Math.PI * 2); ctx.fill();

        // Spike proteins
        for (let si = 0; si < spikeCount; si++) {
            const angle = (si / spikeCount) * Math.PI * 2;
            const wobble = Math.sin(frame * 0.03 + si * 1.7) * 1;
            const sx = Math.cos(angle) * coreR;
            const sy = Math.sin(angle) * coreR;
            const ex = Math.cos(angle) * (coreR + spikeLen + wobble);
            const ey = Math.sin(angle) * (coreR + spikeLen + wobble);
            ctx.strokeStyle = 'rgba(255,7,58,0.35)'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
            const bGrad = ctx.createRadialGradient(ex, ey, 0, ex, ey, bulbR);
            bGrad.addColorStop(0, 'rgba(255,7,58,0.7)'); bGrad.addColorStop(1, 'rgba(255,7,58,0.15)');
            ctx.fillStyle = bGrad;
            ctx.beginPath(); ctx.arc(ex, ey, bulbR, 0, Math.PI * 2); ctx.fill();
        }

        // Core body
        const bodyGrad = ctx.createRadialGradient(-2, -2, 0, 0, 0, coreR);
        bodyGrad.addColorStop(0, 'rgba(255,7,58,0.5)');
        bodyGrad.addColorStop(0.6, 'rgba(255,7,58,0.25)');
        bodyGrad.addColorStop(1, 'rgba(180,40,50,0.12)');
        ctx.fillStyle = bodyGrad;
        ctx.beginPath(); ctx.arc(0, 0, coreR, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = 'rgba(255,7,58,0.3)'; ctx.lineWidth = 0.8;
        ctx.beginPath(); ctx.arc(0, 0, coreR, 0, Math.PI * 2); ctx.stroke();

        // Membrane rings
        ctx.strokeStyle = 'rgba(255,7,58,0.1)'; ctx.lineWidth = 0.4;
        for (let ri = 0; ri < 2; ri++) {
            ctx.beginPath(); ctx.arc(0, 0, 4 + ri * 4, 0, Math.PI * 2); ctx.stroke();
        }

        // Highlight
        const hlGrad = ctx.createRadialGradient(-3, -3, 0, -2, -2, 6);
        hlGrad.addColorStop(0, 'rgba(255,255,255,0.15)'); hlGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = hlGrad;
        ctx.beginPath(); ctx.arc(-2, -2, 6, 0, Math.PI * 2); ctx.fill();

        ctx.restore();

        // "NosoTrack" label to the right of virus
        ctx.fillStyle = '#ffffff'; ctx.globalAlpha = 0.5;
        ctx.font = `600 11px "Source Sans Pro", sans-serif`;
        ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
        ctx.fillText('Noso', logoCx + coreR + spikeLen + 6, logoCy - 1);
        ctx.fillStyle = ACCENT; ctx.globalAlpha = 0.6;
        ctx.fillText('Track', logoCx + coreR + spikeLen + 6 + ctx.measureText('Noso').width, logoCy - 1);
        ctx.globalAlpha = 1; ctx.textBaseline = 'alphabetic';
    }

    // Init
    initBg();
    initEngineViz();

    window.addEventListener('resize', () => {
        initBg();
        Object.keys(vizCanvases).forEach(k => { const c = vizCanvases[k]; const info = initCanvas(c.el); if (info) { c.ctx = info.ctx; c.w = info.w; c.h = info.h; } });
        connectors.forEach(c => { const info = initCanvas(c.el); if (info) { c.ctx = info.ctx; c.w = info.w; c.h = info.h; } });
        initEngineViz();
    });

    function animate() {
        requestAnimationFrame(animate);
        frame++;
        drawBg();
        connectors.forEach(animateConnector);
        vizDNA(); vizContact(); vizEHR(); vizAnon(); vizAlert();
        drawEngineViz();
    }
    setTimeout(() => { requestAnimationFrame(animate); }, 150);
})();

// ==========================================
// 3D TRANSMISSION NETWORK (Three.js)
// ==========================================
(function() {
    const container = document.getElementById('three-container');
    const tooltip = document.getElementById('vizTooltip');
    if (!container) return;

    const W = container.clientWidth;
    const H = container.clientHeight || 550;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1b1f22);
    scene.fog = new THREE.FogExp2(0x1b1f22, 0.0012);

    const camera = new THREE.PerspectiveCamera(55, W / H, 1, 2000);
    camera.position.set(0, 90, 420);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(W, H);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 0.6, 800);
    pointLight.position.set(100, 200, 200);
    scene.add(pointLight);

    const COLORS = { healthy: 0x8a8a8a, infected: 0xff073a, wardA: 0x6496ff, wardB: 0xff9664, wardC: 0x96ff64, edge: 0x555555, edgeInfected: 0xff073a, particle: 0xff073a };

    const nodeData = [
        { id: 1, label: 'P0', ward: 'A', type: 'patient' }, { id: 2, label: 'S1', ward: 'A', type: 'staff' },
        { id: 3, label: 'S2', ward: 'B', type: 'staff' }, { id: 4, label: 'P3', ward: 'A', type: 'patient' },
        { id: 5, label: 'P4', ward: 'A', type: 'patient' }, { id: 6, label: 'P5', ward: 'B', type: 'patient' },
        { id: 7, label: 'P6', ward: 'B', type: 'patient' }, { id: 8, label: 'P7', ward: 'C', type: 'patient' },
        { id: 10, label: 'S3', ward: 'B', type: 'staff' }, { id: 9, label: 'P2', ward: 'A', type: 'patient' },
        { id: 11, label: 'S4', ward: 'A', type: 'staff' }, { id: 12, label: 'P10', ward: 'B', type: 'patient' },
        { id: 13, label: 'S5', ward: 'B', type: 'staff' }, { id: 14, label: 'P12', ward: 'B', type: 'patient' },
        { id: 15, label: 'P13', ward: 'B', type: 'patient' }, { id: 16, label: 'S6', ward: 'C', type: 'staff' },
        { id: 18, label: 'S7', ward: 'C', type: 'staff' }, { id: 19, label: 'P17', ward: 'C', type: 'patient' },
        { id: 20, label: 'P18', ward: 'C', type: 'patient' }, { id: 21, label: 'S8', ward: 'A', type: 'staff' },
        { id: 17, label: 'P15', ward: 'C', type: 'patient' }, { id: 22, label: 'P20', ward: 'A', type: 'patient' },
        { id: 23, label: 'P21', ward: 'A', type: 'patient' },
    ];

    const edgeData = [
        { from: 1, to: 2 }, { from: 1, to: 3 }, { from: 2, to: 4 }, { from: 2, to: 5 },
        { from: 3, to: 6 }, { from: 3, to: 7 }, { from: 3, to: 8 }, { from: 6, to: 10 },
        { from: 10, to: 9 }, { from: 10, to: 11 }, { from: 10, to: 12 }, { from: 10, to: 13 },
        { from: 10, to: 14 }, { from: 10, to: 15 }, { from: 10, to: 16 }, { from: 10, to: 18 },
        { from: 18, to: 19 }, { from: 18, to: 20 }, { from: 9, to: 21 }, { from: 21, to: 22 },
        { from: 21, to: 23 }, { from: 16, to: 17 },
    ];

    const nodeMap = {};
    const wardCenters = { A: { x: -180, z: -80 }, B: { x: 0, z: 90 }, C: { x: 180, z: -40 } };

    nodeData.forEach(n => {
        const wc = wardCenters[n.ward];
        nodeMap[n.id] = { ...n, x: wc.x + (Math.random()-0.5)*100, y: (Math.random()-0.5)*80, z: wc.z + (Math.random()-0.5)*100, vx:0, vy:0, vz:0, infected: false, mesh: null, glow: null };
    });

    function simulateForces(iterations) {
        const nodes = Object.values(nodeMap);
        for (let iter = 0; iter < iterations; iter++) {
            for (let i = 0; i < nodes.length; i++) { for (let j = i+1; j < nodes.length; j++) { const dx = nodes[i].x-nodes[j].x, dy = nodes[i].y-nodes[j].y, dz = nodes[i].z-nodes[j].z; const dist = Math.sqrt(dx*dx+dy*dy+dz*dz)+0.1; const force = 800/(dist*dist); nodes[i].vx += (dx/dist)*force; nodes[i].vy += (dy/dist)*force; nodes[i].vz += (dz/dist)*force; nodes[j].vx -= (dx/dist)*force; nodes[j].vy -= (dy/dist)*force; nodes[j].vz -= (dz/dist)*force; } }
            edgeData.forEach(e => { const a = nodeMap[e.from], b = nodeMap[e.to]; const dx = b.x-a.x, dy = b.y-a.y, dz = b.z-a.z; const dist = Math.sqrt(dx*dx+dy*dy+dz*dz)+0.1; const force = (dist-50)*0.04; a.vx += (dx/dist)*force; a.vy += (dy/dist)*force; a.vz += (dz/dist)*force; b.vx -= (dx/dist)*force; b.vy -= (dy/dist)*force; b.vz -= (dz/dist)*force; });
            nodes.forEach(n => { const wc = wardCenters[n.ward]; n.vx += (wc.x-n.x)*0.025; n.vz += (wc.z-n.z)*0.025; n.vy += (0-n.y)*0.012; });
            nodes.forEach(n => { n.vx *= 0.85; n.vy *= 0.85; n.vz *= 0.85; n.x += n.vx; n.y += n.vy; n.z += n.vz; });
        }
    }
    simulateForces(200);

    const wardConfig = { A: { color: COLORS.wardA, radius: 80 }, B: { color: COLORS.wardB, radius: 90 }, C: { color: COLORS.wardC, radius: 75 } };
    Object.entries(wardCenters).forEach(([ward, center]) => {
        const cfg = wardConfig[ward];
        const discGeo = new THREE.CircleGeometry(cfg.radius, 64);
        const discMat = new THREE.MeshBasicMaterial({ color: cfg.color, transparent: true, opacity: 0.07, side: THREE.DoubleSide, depthWrite: false });
        const disc = new THREE.Mesh(discGeo, discMat); disc.rotation.x = -Math.PI/2; disc.position.set(center.x, -45, center.z); scene.add(disc);
        const ringGeo = new THREE.RingGeometry(cfg.radius-1.5, cfg.radius, 64);
        const ringMat = new THREE.MeshBasicMaterial({ color: cfg.color, transparent: true, opacity: 0.15, side: THREE.DoubleSide, depthWrite: false });
        const ring = new THREE.Mesh(ringGeo, ringMat); ring.rotation.x = -Math.PI/2; ring.position.set(center.x, -44.5, center.z); scene.add(ring);
    });

    function createWardLabel(text, color) {
        const c = document.createElement('canvas'); c.width = 256; c.height = 64;
        const cx = c.getContext('2d'); cx.font = '500 28px "JetBrains Mono", monospace'; cx.textAlign = 'center'; cx.textBaseline = 'middle';
        cx.fillStyle = '#' + new THREE.Color(color).getHexString(); cx.globalAlpha = 0.7; cx.fillText(text, 128, 32);
        const texture = new THREE.CanvasTexture(c);
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
        const sprite = new THREE.Sprite(mat); sprite.scale.set(80, 20, 1); return sprite;
    }
    Object.entries(wardCenters).forEach(([ward, center]) => { const label = createWardLabel('Ward ' + ward, wardConfig[ward].color); label.position.set(center.x, 55, center.z); scene.add(label); });

    const nodeMeshes = [], glowMeshes = [];
    Object.values(nodeMap).forEach(n => {
        const wardColor = COLORS['ward' + n.ward]; const isStaff = n.type === 'staff'; const size = n.id === 10 ? 7 : (isStaff ? 4.5 : 5);
        const geometry = isStaff ? new THREE.OctahedronGeometry(size, 0) : new THREE.SphereGeometry(size, 16, 16);
        const material = new THREE.MeshPhongMaterial({ color: COLORS.healthy, emissive: 0x111111, shininess: 60, transparent: true, opacity: 0.9 });
        const mesh = new THREE.Mesh(geometry, material); mesh.position.set(n.x, n.y, n.z);
        mesh.userData = { nodeId: n.id, label: n.label, ward: n.ward, type: n.type, wardColor }; scene.add(mesh); n.mesh = mesh; nodeMeshes.push(mesh);
        const glowGeo = new THREE.SphereGeometry(size * 2.5, 12, 12);
        const glowMat = new THREE.MeshBasicMaterial({ color: COLORS.infected, transparent: true, opacity: 0 });
        const glow = new THREE.Mesh(glowGeo, glowMat); glow.position.copy(mesh.position); scene.add(glow); n.glow = glow; glowMeshes.push(glow);
    });

    const edgeMeshes = [];
    edgeData.forEach(e => {
        const a = nodeMap[e.from], b = nodeMap[e.to];
        const points = [new THREE.Vector3(a.x, a.y, a.z), new THREE.Vector3(b.x, b.y, b.z)];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: COLORS.edge, transparent: true, opacity: 0.4 });
        const line = new THREE.Line(geometry, material); line.userData = { from: e.from, to: e.to }; scene.add(line); edgeMeshes.push(line);
    });

    const transmissionParticles = [];
    const SWARM_COUNT = 18; // particles per transmission
    function createTransmissionParticle(fromId, toId) {
        const a = nodeMap[fromId], b = nodeMap[toId];
        const from = new THREE.Vector3(a.x, a.y, a.z);
        const to = new THREE.Vector3(b.x, b.y, b.z);
        const swarm = [];
        for (let i = 0; i < SWARM_COUNT; i++) {
            const size = 0.4 + Math.random() * 0.8;
            const geo = new THREE.SphereGeometry(size, 4, 4);
            const mat = new THREE.MeshBasicMaterial({ color: COLORS.particle, transparent: true, opacity: 0.8 + Math.random() * 0.2 });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.copy(from); scene.add(mesh);
            // Each particle has its own offset, speed variation, and drift
            swarm.push({
                mesh, delay: i * 0.012 + Math.random() * 0.04,
                drift: new THREE.Vector3((Math.random()-0.5)*12, (Math.random()-0.5)*12, (Math.random()-0.5)*12),
                speedVar: 0.85 + Math.random() * 0.3,
                baseOpacity: 0.5 + Math.random() * 0.5
            });
        }
        // Add a faint glow line along the edge that builds up
        const edgeGlowGeo = new THREE.BufferGeometry().setFromPoints([from.clone(), from.clone()]);
        const edgeGlowMat = new THREE.LineBasicMaterial({ color: COLORS.particle, transparent: true, opacity: 0.15 });
        const edgeGlow = new THREE.Line(edgeGlowGeo, edgeGlowMat); scene.add(edgeGlow);
        transmissionParticles.push({ swarm, edgeGlow, edgeGlowGeo, from: from.clone(), to: to.clone(), progress: 0, targetId: toId, speed: 0.01 + Math.random() * 0.006 });
    }

    const infectedSet = new Set();
    let simQueue = [], simTimer = 0;
    const SIM_INTERVAL = 80;

    function resetSimulation() {
        infectedSet.clear();
        transmissionParticles.forEach(p => { p.swarm.forEach(s => scene.remove(s.mesh)); scene.remove(p.edgeGlow); }); transmissionParticles.length = 0;
        Object.values(nodeMap).forEach(n => { n.infected = false; n.mesh.material.color.setHex(COLORS.healthy); n.mesh.material.emissive.setHex(0x000000); n.glow.material.opacity = 0; });
        edgeMeshes.forEach(e => { e.material.color.setHex(COLORS.edge); e.material.opacity = 0.4; });
        simQueue = [];
        const visited = new Set(); const queue = [1]; visited.add(1); infectNode(1);
        while (queue.length > 0) { const current = queue.shift(); const downstream = edgeData.filter(e => e.from === current && !visited.has(e.to)); downstream.forEach(e => { visited.add(e.to); simQueue.push({ from: current, to: e.to }); queue.push(e.to); }); }
    }

    function infectNode(id) { const n = nodeMap[id]; if (!n) return; n.infected = true; infectedSet.add(id); n.mesh.material.color.setHex(COLORS.infected); n.mesh.material.emissive.setHex(0x7a031b); }
    resetSimulation();

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredNode = null;

    container.addEventListener('mousemove', (event) => {
        const rect = container.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(nodeMeshes);
        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (hoveredNode !== obj) { if (hoveredNode) resetHighlight(); hoveredNode = obj; highlightConnections(obj.userData.nodeId); tooltip.style.display = 'block'; tooltip.textContent = `${obj.userData.label} (${obj.userData.type}) — Ward ${obj.userData.ward}`; }
            tooltip.style.left = (event.clientX - container.getBoundingClientRect().left + 12) + 'px';
            tooltip.style.top = (event.clientY - container.getBoundingClientRect().top - 12) + 'px';
            container.style.cursor = 'pointer';
        } else { if (hoveredNode) { resetHighlight(); hoveredNode = null; } tooltip.style.display = 'none'; container.style.cursor = 'default'; }
    });
    container.addEventListener('mouseleave', () => { if (hoveredNode) { resetHighlight(); hoveredNode = null; } tooltip.style.display = 'none'; });

    function highlightConnections(nodeId) {
        nodeMeshes.forEach(m => { m.material.opacity = 0.2; }); edgeMeshes.forEach(e => { e.material.opacity = 0.05; });
        const connectedIds = new Set([nodeId]); edgeData.forEach(e => { if (e.from === nodeId) connectedIds.add(e.to); if (e.to === nodeId) connectedIds.add(e.from); });
        nodeMeshes.forEach(m => { if (connectedIds.has(m.userData.nodeId)) m.material.opacity = 1; });
        edgeMeshes.forEach(e => { if (e.userData.from === nodeId || e.userData.to === nodeId) { e.material.opacity = 0.8; e.material.color.setHex(0xffffff); } });
    }

    function resetHighlight() {
        nodeMeshes.forEach(m => { m.material.opacity = 0.9; });
        edgeMeshes.forEach(e => { const fi = nodeMap[e.userData.from].infected, ti = nodeMap[e.userData.to].infected; if (fi && ti) { e.material.color.setHex(COLORS.edgeInfected); e.material.opacity = 0.5; } else { e.material.color.setHex(COLORS.edge); e.material.opacity = 0.4; } });
    }

    let time = 0, orbitAngle = 0;
    function animateViz() {
        requestAnimationFrame(animateViz);
        time++; orbitAngle += 0.002;
        camera.position.x = Math.sin(orbitAngle) * 420;
        camera.position.z = Math.cos(orbitAngle) * 420;
        camera.position.y = 90 + Math.sin(orbitAngle * 0.5) * 40;
        camera.lookAt(0, 0, 0);
        nodeMeshes.forEach(m => { const s = 1 + Math.sin(time * 0.03 + m.userData.nodeId) * 0.05; m.scale.set(s, s, s); });
        glowMeshes.forEach((g, i) => { const n = Object.values(nodeMap)[i]; if (n.infected) { g.material.opacity = 0.12 + Math.sin(time * 0.05 + n.id) * 0.06; g.position.copy(n.mesh.position); } else { g.material.opacity = 0; } });
        simTimer++;
        if (simTimer > SIM_INTERVAL && simQueue.length > 0) {
            simTimer = 0;
            const next = simQueue[0];
            if (next.from === 10) { const batch = []; while (simQueue.length > 0 && simQueue[0].from === 10) batch.push(simQueue.shift()); batch.forEach(t => createTransmissionParticle(t.from, t.to)); }
            else { simQueue.shift(); createTransmissionParticle(next.from, next.to); }
        }
        if (simQueue.length === 0 && transmissionParticles.length === 0 && infectedSet.size > 1) { simTimer = -200; if (simTimer === -200) { setTimeout(() => resetSimulation(), 4000); simQueue.push({}); } }
        for (let i = transmissionParticles.length - 1; i >= 0; i--) {
            const p = transmissionParticles[i]; p.progress += p.speed;
            // Check if all particles have arrived
            const allArrived = p.progress >= 1.15;
            if (allArrived) {
                infectNode(p.targetId);
                edgeData.forEach((ed, idx) => { if ((ed.from === p.targetId || ed.to === p.targetId) && nodeMap[ed.from].infected && nodeMap[ed.to].infected) { edgeMeshes[idx].material.color.setHex(COLORS.edgeInfected); edgeMeshes[idx].material.opacity = 0.5; } });
                p.swarm.forEach(s => scene.remove(s.mesh));
                scene.remove(p.edgeGlow); transmissionParticles.splice(i, 1); continue;
            }
            // Update edge glow line to show progress
            const glowEnd = new THREE.Vector3().lerpVectors(p.from, p.to, Math.min(p.progress * 1.1, 1));
            const glowPositions = p.edgeGlowGeo.attributes.position.array;
            glowPositions[3] = glowEnd.x; glowPositions[4] = glowEnd.y; glowPositions[5] = glowEnd.z;
            p.edgeGlowGeo.attributes.position.needsUpdate = true;
            p.edgeGlow.material.opacity = 0.2 + Math.sin(time * 0.1) * 0.05;
            // Animate each swarm particle
            p.swarm.forEach(s => {
                const particleProgress = Math.max(0, Math.min(1, (p.progress - s.delay) * s.speedVar));
                if (particleProgress <= 0) { s.mesh.visible = false; return; }
                s.mesh.visible = true;
                const basePos = new THREE.Vector3().lerpVectors(p.from, p.to, particleProgress);
                // Add arc and drift
                const arcHeight = Math.sin(particleProgress * Math.PI) * 12;
                basePos.y += arcHeight;
                // Drift diminishes as particle approaches target
                const driftScale = Math.sin(particleProgress * Math.PI) * 0.8;
                basePos.x += s.drift.x * driftScale;
                basePos.y += s.drift.y * driftScale;
                basePos.z += s.drift.z * driftScale;
                s.mesh.position.copy(basePos);
                // Fade: bright in middle, fade at arrival
                const fadeIn = Math.min(1, particleProgress * 4);
                const fadeOut = particleProgress > 0.8 ? 1 - (particleProgress - 0.8) / 0.2 : 1;
                s.mesh.material.opacity = s.baseOpacity * fadeIn * fadeOut;
                // Slight pulse
                const pulse = 1 + Math.sin(time * 0.15 + s.delay * 20) * 0.15;
                s.mesh.scale.setScalar(pulse);
            });
        }
        renderer.render(scene, camera);
    }
    animateViz();

    window.addEventListener('resize', () => {
        const w = container.clientWidth, h = container.clientHeight;
        camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h);
    });
})();
</script>

<script src="content-loader.js"></script>
</body>
</html>
