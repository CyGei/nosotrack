<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NosoTrack — Real-Time Nosocomial Outbreak Analytics</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;600;700;800&family=JetBrains+Mono:wght@400;500&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ========== RESET & BASE ========== */
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            font-family: 'Inter', sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
            font-weight: 300;
            line-height: 1.7;
        }
        a { color: inherit; text-decoration: none; }
        img { max-width: 100%; display: block; }

        /* ========== VARIABLES ========== */
        :root {
            --accent: #e63946;
            --accent-dim: rgba(230, 57, 70, 0.15);
            --accent-glow: rgba(230, 57, 70, 0.4);
            --bg: #0a0a0a;
            --bg-card: #111111;
            --bg-card-hover: #1a1a1a;
            --text-primary: #f0f0f0;
            --text-secondary: #888888;
            --text-dim: #555555;
            --border: rgba(255,255,255,0.06);
            --mono: 'JetBrains Mono', monospace;
            --display: 'Syne', sans-serif;
            --body: 'Inter', sans-serif;
            --container: 1200px;
        }

        /* ========== UTILITIES ========== */
        .container { max-width: var(--container); margin: 0 auto; padding: 0 24px; }
        .section-tag {
            font-family: var(--mono);
            font-size: 0.75rem;
            color: var(--accent);
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 16px;
            display: block;
        }
        .section-title {
            font-family: var(--display);
            font-weight: 800;
            font-size: clamp(2.5rem, 5vw, 4.5rem);
            color: var(--text-primary);
            line-height: 1.1;
            margin-bottom: 24px;
        }
        .section-padding { padding: 120px 0; }

        /* ========== SCROLL ANIMATIONS ========== */
        .reveal {
            opacity: 0;
            transform: translateY(40px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }
        .reveal.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* ========== NAV ========== */
        nav.main-nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
            background: rgba(10,10,10,0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
        }
        .nav-inner {
            max-width: var(--container);
            margin: 0 auto;
            padding: 0 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 72px;
        }
        .nav-logo {
            font-family: var(--display);
            font-weight: 800;
            font-size: 1.3rem;
            color: var(--text-primary);
            letter-spacing: -0.5px;
        }
        .nav-logo span { color: var(--accent); }
        .nav-links {
            display: flex;
            align-items: center;
            gap: 32px;
            list-style: none;
        }
        .nav-links a {
            font-family: var(--mono);
            font-size: 0.75rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-secondary);
            transition: color 0.3s;
        }
        .nav-links a:hover { color: var(--text-primary); }
        .nav-cta {
            background: var(--accent);
            color: #fff !important;
            padding: 10px 24px;
            border-radius: 4px;
            font-weight: 500;
            transition: background 0.3s, transform 0.2s;
        }
        .nav-cta:hover { background: #c1303c; transform: translateY(-1px); }
        .nav-hamburger {
            display: none;
            flex-direction: column;
            gap: 5px;
            cursor: pointer;
            background: none;
            border: none;
            padding: 4px;
        }
        .nav-hamburger span {
            width: 24px;
            height: 2px;
            background: var(--text-primary);
            transition: transform 0.3s, opacity 0.3s;
        }

        /* ========== HERO ========== */
        #hero {
            position: relative;
            min-height: 100vh;
            display: flex;
            align-items: center;
            overflow: hidden;
        }
        #network-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        .hero-content {
            position: relative;
            z-index: 2;
            max-width: var(--container);
            margin: 0 auto;
            padding: 0 24px;
            padding-top: 100px;
        }
        .hero-eyebrow {
            font-family: var(--mono);
            font-size: 0.8rem;
            letter-spacing: 4px;
            text-transform: uppercase;
            color: var(--accent);
            margin-bottom: 24px;
        }
        .hero-title {
            font-family: var(--display);
            font-weight: 800;
            font-size: clamp(3rem, 7vw, 7rem);
            line-height: 1.05;
            color: var(--text-primary);
            margin-bottom: 28px;
        }
        .hero-title .accent { color: var(--accent); }
        .hero-subtitle {
            font-size: 1.15rem;
            color: var(--text-secondary);
            max-width: 580px;
            line-height: 1.8;
            margin-bottom: 40px;
        }
        .hero-buttons { display: flex; gap: 16px; flex-wrap: wrap; }
        .btn-primary {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: var(--accent);
            color: #fff;
            padding: 14px 32px;
            border-radius: 4px;
            font-family: var(--mono);
            font-size: 0.85rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            transition: background 0.3s, transform 0.2s;
            border: none;
            cursor: pointer;
        }
        .btn-primary:hover { background: #c1303c; transform: translateY(-2px); }
        .btn-secondary {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: transparent;
            color: var(--text-primary);
            padding: 14px 32px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.15);
            font-family: var(--mono);
            font-size: 0.85rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            transition: border-color 0.3s, transform 0.2s;
            cursor: pointer;
        }
        .btn-secondary:hover { border-color: var(--accent); transform: translateY(-2px); }

        /* ========== MARQUEE ========== */
        .marquee-section {
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
            padding: 20px 0;
            overflow: hidden;
            background: var(--bg);
        }
        .marquee-track {
            display: flex;
            gap: 60px;
            animation: marquee 30s linear infinite;
            width: max-content;
        }
        .marquee-track span {
            font-family: var(--mono);
            font-size: 0.8rem;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: var(--text-dim);
            white-space: nowrap;
        }
        .marquee-track span::after {
            content: '//';
            margin-left: 60px;
            color: var(--accent);
            opacity: 0.5;
        }
        @keyframes marquee {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        /* ========== STATS ========== */
        #stats {
            padding: 80px 0;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
        }
        .stat-card {
            background: var(--bg-card);
            padding: 48px 32px;
            text-align: center;
            border: 1px solid var(--border);
            transition: background 0.3s;
        }
        .stat-card:hover { background: var(--bg-card-hover); }
        .stat-label {
            font-family: var(--mono);
            font-size: 0.7rem;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }
        .stat-value {
            font-family: var(--display);
            font-weight: 800;
            font-size: clamp(2.5rem, 4vw, 3.5rem);
            color: var(--text-primary);
            line-height: 1;
            margin-bottom: 8px;
        }
        .stat-sub {
            font-family: var(--mono);
            font-size: 0.65rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--text-dim);
        }
        .stat-accent-line {
            width: 40px;
            height: 2px;
            background: var(--accent);
            margin: 16px auto 0;
        }

        /* ========== ABOUT ========== */
        #about .about-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 80px;
            align-items: start;
        }
        .about-text p {
            color: var(--text-secondary);
            margin-bottom: 24px;
            text-align: justify;
            font-size: 1.02rem;
        }
        .about-text strong { color: var(--text-primary); font-weight: 500; }
        .about-text em { color: var(--text-secondary); font-style: italic; }
        .nosotrack-highlight {
            color: var(--accent);
            font-weight: 700;
            font-family: var(--mono);
            font-size: 1.1rem;
        }
        .about-visual {
            position: relative;
        }
        #viz-container {
            width: 100%;
            aspect-ratio: 4/3;
            background: rgba(0,0,0,0.4);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
        }

        /* ========== HOW IT WORKS ========== */
        #how-it-works { background: var(--bg-card); }
        .steps-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 32px;
            margin-top: 64px;
        }
        .step-card {
            position: relative;
            padding: 48px 32px 40px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg);
            transition: border-color 0.3s, transform 0.3s;
            overflow: hidden;
        }
        .step-card:hover {
            border-color: rgba(230,57,70,0.3);
            transform: translateY(-4px);
        }
        .step-number {
            font-family: var(--display);
            font-weight: 800;
            font-size: 6rem;
            line-height: 1;
            color: transparent;
            -webkit-text-stroke: 1px rgba(255,255,255,0.06);
            position: absolute;
            top: -10px;
            right: 16px;
        }
        .step-label {
            font-family: var(--mono);
            font-size: 0.7rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--accent);
            margin-bottom: 16px;
        }
        .step-title {
            font-family: var(--display);
            font-weight: 700;
            font-size: 1.5rem;
            color: var(--text-primary);
            margin-bottom: 16px;
        }
        .step-desc {
            color: var(--text-secondary);
            font-size: 0.95rem;
            line-height: 1.7;
        }

        /* ========== PIPELINE ========== */
        #pipeline-canvas {
            width: 100%;
            height: 340px;
            display: block;
            margin-top: 48px;
            border: 1px solid var(--border);
            border-radius: 8px;
        }
        .pipeline-fallback {
            margin-top: 48px;
        }
        .pipeline-fallback ol {
            list-style: none;
            counter-reset: pipeline-step;
        }
        .pipeline-fallback li {
            counter-increment: pipeline-step;
            padding: 16px 0;
            border-bottom: 1px solid var(--border);
            font-family: var(--mono);
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        .pipeline-fallback li::before {
            content: counter(pipeline-step, decimal-leading-zero) ' ';
            color: var(--accent);
            font-weight: 600;
            margin-right: 12px;
        }

        /* ========== RESEARCH ========== */
        .research-intro {
            max-width: 700px;
            color: var(--text-secondary);
            margin-bottom: 48px;
            font-size: 1.05rem;
            text-align: justify;
        }
        .research-sub {
            font-family: var(--mono);
            font-size: 0.75rem;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: var(--text-dim);
            margin-bottom: 24px;
        }
        .pub-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }
        .pub-card {
            display: block;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 28px;
            transition: border-color 0.3s, transform 0.3s, background 0.3s;
        }
        .pub-card:hover {
            border-color: rgba(230,57,70,0.3);
            background: var(--bg-card-hover);
            transform: translateY(-2px);
        }
        .pub-tag {
            font-family: var(--mono);
            font-size: 0.65rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--accent);
            background: var(--accent-dim);
            padding: 4px 10px;
            border-radius: 3px;
            display: inline-block;
            margin-bottom: 12px;
        }
        .pub-title {
            font-family: var(--display);
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 8px;
        }
        .pub-desc {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        .pub-arrow {
            display: inline-block;
            margin-top: 12px;
            color: var(--accent);
            font-size: 0.85rem;
            transition: transform 0.3s;
        }
        .pub-card:hover .pub-arrow { transform: translateX(4px); }

        /* ========== TEAM ========== */
        #team { background: var(--bg-card); }
        .team-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 24px;
            margin-top: 48px;
        }
        .team-card {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            transition: border-color 0.3s, transform 0.3s;
        }
        .team-card:hover {
            border-color: rgba(230,57,70,0.3);
            transform: translateY(-4px);
        }
        .team-photo {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            filter: grayscale(30%);
            transition: filter 0.3s;
        }
        .team-card:hover .team-photo { filter: grayscale(0%); }
        .team-info { padding: 20px; }
        .team-name {
            font-family: var(--display);
            font-weight: 700;
            font-size: 1.05rem;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .team-role {
            font-family: var(--mono);
            font-size: 0.7rem;
            letter-spacing: 1px;
            color: var(--accent);
            margin-bottom: 12px;
        }
        .team-bio {
            color: var(--text-secondary);
            font-size: 0.85rem;
            line-height: 1.6;
        }
        .team-bio a {
            color: var(--accent);
            text-decoration: underline;
            text-underline-offset: 2px;
        }
        .team-bio a:hover { color: var(--text-primary); }

        /* ========== CONTACT ========== */
        #contact .contact-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 80px;
            align-items: start;
        }
        .contact-heading {
            font-family: var(--display);
            font-weight: 800;
            font-size: clamp(2rem, 4vw, 3.5rem);
            color: var(--text-primary);
            line-height: 1.1;
            margin-bottom: 20px;
        }
        .contact-sub {
            color: var(--text-secondary);
            font-size: 1.05rem;
            margin-bottom: 32px;
        }
        .contact-form label {
            font-family: var(--mono);
            font-size: 0.7rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--text-secondary);
            display: block;
            margin-bottom: 8px;
        }
        .contact-form input,
        .contact-form textarea {
            width: 100%;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 14px 16px;
            color: var(--text-primary);
            font-family: var(--body);
            font-size: 0.95rem;
            margin-bottom: 20px;
            transition: border-color 0.3s;
            outline: none;
        }
        .contact-form input:focus,
        .contact-form textarea:focus { border-color: var(--accent); }
        .contact-form textarea { resize: vertical; min-height: 120px; }
        .form-buttons { display: flex; gap: 12px; }

        /* ========== FOOTER ========== */
        footer {
            border-top: 1px solid var(--border);
            padding: 48px 0;
        }
        .footer-inner {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 16px;
        }
        .footer-logo {
            font-family: var(--display);
            font-weight: 800;
            font-size: 1.1rem;
            color: var(--text-primary);
        }
        .footer-logo span { color: var(--accent); }
        .footer-links {
            display: flex;
            gap: 24px;
            list-style: none;
        }
        .footer-links a {
            font-family: var(--mono);
            font-size: 0.7rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-dim);
            transition: color 0.3s;
        }
        .footer-links a:hover { color: var(--text-primary); }
        .footer-copy {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        /* ========== RESPONSIVE ========== */
        @media (max-width: 1024px) {
            .about-grid, .contact-grid { grid-template-columns: 1fr; gap: 48px; }
            .steps-grid { grid-template-columns: 1fr; }
            .team-grid { grid-template-columns: repeat(2, 1fr); }
        }
        @media (max-width: 768px) {
            .nav-links { display: none; }
            .nav-links.open {
                display: flex;
                flex-direction: column;
                position: fixed;
                top: 72px;
                left: 0;
                width: 100%;
                background: rgba(10,10,10,0.98);
                backdrop-filter: blur(20px);
                padding: 32px 24px;
                gap: 24px;
                border-bottom: 1px solid var(--border);
            }
            .nav-hamburger { display: flex; }
            .stats-grid { grid-template-columns: 1fr; }
            .pub-grid { grid-template-columns: 1fr; }
            .team-grid { grid-template-columns: 1fr; }
            .hero-title { font-size: clamp(2.5rem, 10vw, 4rem); }
            .section-padding { padding: 80px 0; }
            #pipeline-canvas { height: 700px; }
        }

        /* ========== 3D VIZ ========== */
        #three-container {
            width: 100%;
            height: 650px;
            position: relative;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 48px;
        }
        #three-container canvas { display: block; }
        .viz-legend {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(10,10,10,0.85);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 16px;
            font-family: var(--mono);
            font-size: 0.7rem;
            letter-spacing: 1px;
            color: var(--text-secondary);
            z-index: 10;
        }
        .viz-legend-title {
            font-weight: 600;
            color: var(--text-dim);
            font-size: 0.6rem;
            margin-bottom: 8px;
            letter-spacing: 2px;
        }
        .viz-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        .viz-legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        .viz-legend-tri {
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 9px solid #888;
        }
        .viz-tooltip {
            position: absolute;
            background: rgba(10,10,10,0.9);
            border: 1px solid var(--accent);
            border-radius: 4px;
            padding: 8px 12px;
            font-family: var(--mono);
            font-size: 0.75rem;
            color: var(--text-primary);
            pointer-events: none;
            z-index: 20;
            display: none;
        }
    </style>
</head>
<body>

<!-- ========== NAV ========== -->
<nav class="main-nav">
    <div class="nav-inner">
        <a href="#" class="nav-logo">Noso<span>Track</span></a>
        <ul class="nav-links" id="navLinks">
            <li><a href="#about">About</a></li>
            <li><a href="#how-it-works">Process</a></li>
            <li><a href="#research">Research</a></li>
            <li><a href="#team">Team</a></li>
            <li><a href="#contact" class="nav-cta">Get in Touch</a></li>
        </ul>
        <button class="nav-hamburger" id="navToggle" aria-label="Toggle navigation">
            <span></span><span></span><span></span>
        </button>
    </div>
</nav>

<!-- ========== HERO ========== -->
<section id="hero">
    <canvas id="network-canvas"></canvas>
    <div class="hero-content">
        <div class="hero-eyebrow">Real-Time Outbreak Analytics</div>
        <h1 class="hero-title">
            Track. Trace.<br><span class="accent">Intervene.</span>
        </h1>
        <p class="hero-subtitle">
            NosoTrack infers who infected whom in near real-time, empowering hospital infection prevention teams to stop outbreaks before they escalate.
        </p>
        <div class="hero-buttons">
            <a href="#about" class="btn-primary">Learn More &darr;</a>
            <a href="#contact" class="btn-secondary">Collaborate</a>
        </div>
    </div>
</section>

<!-- ========== MARQUEE ========== -->
<div class="marquee-section">
    <div class="marquee-track">
        <span>Outbreak Reconstruction</span>
        <span>Contact Tracing</span>
        <span>Genomic Surveillance</span>
        <span>Transmission Trees</span>
        <span>Real-Time Analytics</span>
        <span>Infection Prevention</span>
        <span>Hospital Epidemiology</span>
        <span>Superspreader Detection</span>
        <span>Outbreak Reconstruction</span>
        <span>Contact Tracing</span>
        <span>Genomic Surveillance</span>
        <span>Transmission Trees</span>
        <span>Real-Time Analytics</span>
        <span>Infection Prevention</span>
        <span>Hospital Epidemiology</span>
        <span>Superspreader Detection</span>
    </div>
</div>

<!-- ========== STATS ========== -->
<section id="stats">
    <div class="container">
        <div class="stats-grid reveal">
            <div class="stat-card">
                <div class="stat-label">Cases</div>
                <div class="stat-value">2.0M</div>
                <div class="stat-sub">US per year</div>
                <div class="stat-accent-line"></div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Deaths</div>
                <div class="stat-value">100K</div>
                <div class="stat-sub">US per year</div>
                <div class="stat-accent-line"></div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Cost</div>
                <div class="stat-value">$40B+</div>
                <div class="stat-sub">US per year</div>
                <div class="stat-accent-line"></div>
            </div>
        </div>
    </div>
</section>

<!-- ========== ABOUT ========== -->
<section id="about" class="section-padding">
    <div class="container">
        <div class="about-grid">
            <div class="about-text reveal">
                <span class="section-tag">01 — About</span>
                <h2 class="section-title">The Problem<br>& The Solution</h2>
                <p>
                    <strong>Healthcare-associated infections (HAIs)</strong> affect approximately 1 in 10 patients worldwide, causing significant morbidity, mortality, and economic strain on healthcare systems. <strong>Nosocomial outbreaks</strong> driven by person-to-person transmitted pathogens such as SARS-CoV-2, <em>Clostridioides difficile</em>, <em>Klebsiella pneumoniae</em>, and MRSA generate the most acute clinical and operational crises: triggering staff shortages, ward closures, and delayed procedures. Current control measures rely on broad testing and isolation protocols, but <strong>effective intervention requires identifying the specific drivers of an outbreak</strong>: such as patient zero, superspreaders, transmission routes, and undetected or imported cases.
                </p>
                <p>
                    <span class="nosotrack-highlight">NosoTrack</span> <strong>is an outbreak analytics platform that infers who infected whom in near real-time</strong> by integrating data from hospital Electronic Health Records with Bluetooth enabled contact tracing. It delivers early warnings and actionable reports, enabling hospital infection prevention teams to target interventions promptly before an outbreak escalates.
                </p>
            </div>
            <div class="about-visual reveal" style="transition-delay: 0.2s;">
                <div id="three-container">
                    <div class="viz-legend">
                        <div class="viz-legend-title">TYPE</div>
                        <div class="viz-legend-item"><div class="viz-legend-dot" style="background:#888;"></div> Patient</div>
                        <div class="viz-legend-item"><div class="viz-legend-tri"></div> Staff</div>
                        <div style="margin-top:12px;"></div>
                        <div class="viz-legend-title">WARD</div>
                        <div class="viz-legend-item"><div class="viz-legend-dot" style="background:rgba(100,150,255,0.7);"></div> Ward A</div>
                        <div class="viz-legend-item"><div class="viz-legend-dot" style="background:rgba(255,150,100,0.7);"></div> Ward B</div>
                        <div class="viz-legend-item"><div class="viz-legend-dot" style="background:rgba(150,255,100,0.7);"></div> Ward C</div>
                        <div style="margin-top:12px;"></div>
                        <div class="viz-legend-title">STATUS</div>
                        <div class="viz-legend-item"><div class="viz-legend-dot" style="background:#555;"></div> Susceptible</div>
                        <div class="viz-legend-item"><div class="viz-legend-dot" style="background:#e63946; box-shadow: 0 0 6px rgba(230,57,70,0.6);"></div> Infected</div>
                    </div>
                    <div class="viz-tooltip" id="vizTooltip"></div>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- ========== HOW IT WORKS ========== -->
<section id="how-it-works" class="section-padding">
    <div class="container">
        <span class="section-tag reveal">02 — Process</span>
        <h2 class="section-title reveal">How It Works</h2>
        <canvas id="pipeline-canvas" class="reveal"></canvas>
        <noscript>
            <div class="pipeline-fallback">
                <ol>
                    <li><strong>DNA Sequencing</strong> — Pathogen genomes are sequenced and read</li>
                    <li><strong>Contact Tracing</strong> — Bluetooth devices detect proximity between individuals</li>
                    <li><strong>Electronic Health Records</strong> — Clinical data is extracted from hospital systems</li>
                    <li><strong>Data Anonymisation</strong> — Patient identifiers are masked and encrypted</li>
                    <li><strong>Data Merging</strong> — Multiple data streams converge into NosoTrack</li>
                    <li><strong>Transmission Tree Reconstruction</strong> — Statistical models infer who infected whom</li>
                    <li><strong>Warning System</strong> — Alert notifications are dispatched to IPC teams</li>
                </ol>
            </div>
        </noscript>
    </div>
</section>

<!-- ========== RESEARCH ========== -->
<section id="research" class="section-padding">
    <div class="container">
        <span class="section-tag reveal">03 — Research</span>
        <h2 class="section-title reveal">Publications<br>& Software</h2>
        <p class="research-intro reveal">
            Novel computational methods that reconstruct who infected whom from clinical, contact, and genetic data have proven effective in guiding outbreak control across pathogens such as SARS-CoV-2, influenza, Ebola, and antimicrobial-resistant bacteria. Yet, they remain largely retrospective, with no integration into routine hospital surveillance. What is lacking is an automated system capable of deploying these models in near real-time: this is the aim of <span class="nosotrack-highlight">NosoTrack</span>.
        </p>

        <h3 class="research-sub reveal">Selected Publications</h3>
        <div class="pub-grid reveal">
            <a class="pub-card" href="https://pubmed.ncbi.nlm.nih.gov/35215195/" target="_blank">
                <span class="pub-tag">Paper</span>
                <div class="pub-title">Literature review</div>
                <div class="pub-desc">A systematic review of outbreak reconstruction methods.</div>
                <span class="pub-arrow">&rarr;</span>
            </a>
            <a class="pub-card" href="https://link.springer.com/article/10.1186/s12859-018-2330-z" target="_blank">
                <span class="pub-tag">Paper</span>
                <div class="pub-title">A modular platform for outbreak reconstruction</div>
                <div class="pub-desc">The paper for outbreaker2.</div>
                <span class="pub-arrow">&rarr;</span>
            </a>
            <a class="pub-card" href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0313037" target="_blank">
                <span class="pub-tag">Paper</span>
                <div class="pub-title">linktree</div>
                <div class="pub-desc">A method to infer transmission patterns between staff and patients.</div>
                <span class="pub-arrow">&rarr;</span>
            </a>
            <a class="pub-card" href="https://pubmed.ncbi.nlm.nih.gov/40302215/" target="_blank">
                <span class="pub-tag">Paper</span>
                <div class="pub-title">Real time genomic surveillance for nosocomial outbreaks</div>
                <div class="pub-desc">Proof of concept for near real time surveillance.</div>
                <span class="pub-arrow">&rarr;</span>
            </a>
        </div>

        <h3 class="research-sub reveal" style="margin-top: 48px;">Software</h3>
        <div class="pub-grid reveal">
            <a class="pub-card" href="https://github.com/reconhub/outbreaker2" target="_blank">
                <span class="pub-tag">Software</span>
                <div class="pub-title">outbreaker2</div>
                <div class="pub-desc">Software to reconstruct transmission trees.</div>
                <span class="pub-arrow">&rarr;</span>
            </a>
            <a class="pub-card" href="https://cygei.github.io/o2ools/index.html" target="_blank">
                <span class="pub-tag">Software</span>
                <div class="pub-title">o2ools</div>
                <div class="pub-desc">Software to analyse transmission trees.</div>
                <span class="pub-arrow">&rarr;</span>
            </a>
        </div>
    </div>
</section>

<!-- ========== TEAM ========== -->
<section id="team" class="section-padding">
    <div class="container">
        <span class="section-tag reveal">04 — Team</span>
        <h2 class="section-title reveal">The People<br>Behind NosoTrack</h2>
        <div class="team-grid">
            <div class="team-card reveal">
                <img src="images/cyril.jpg" alt="Dr Cyril Geismar" class="team-photo">
                <div class="team-info">
                    <div class="team-name">Dr Cyril Geismar</div>
                    <div class="team-role">Johns Hopkins University</div>
                    <p class="team-bio">Postdoctoral research fellow. PhD in mathematical modelling of infectious diseases at Imperial College London, focused on SARS-CoV-2 outbreak reconstruction. Executive board member and developer for the <a href="https://www.repidemicsconsortium.org/" target="_blank">R Epidemics Consortium</a>. Teaches outbreak analytics at <a href="https://sismid.sph.emory.edu/online-modules/recon-tools/index.html" target="_blank">Emory University</a> and <a href="https://data.org/our-work/epiverse/training-africa/course/" target="_blank">LSHTM</a>.</p>
                </div>
            </div>
            <div class="team-card reveal" style="transition-delay: 0.1s;">
                <img src="images/thibaut.jpg" alt="Dr Thibaut Jombart" class="team-photo">
                <div class="team-info">
                    <div class="team-name">Dr Thibaut Jombart</div>
                    <div class="team-role">Imperial College London</div>
                    <p class="team-bio">Senior Lecturer specialising in outbreak response analytics, biostatistics, population genetics, and R programming. Lead author of <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003457" target="_blank">outbreaker</a> and founder of the <a href="https://www.repidemicsconsortium.org/" target="_blank">R Epidemics Consortium</a>. Field experience in Ebola deployments in the Democratic Republic of the Congo.</p>
                </div>
            </div>
            <div class="team-card reveal" style="transition-delay: 0.2s;">
                <img src="images/anne.jpg" alt="Dr Anne Cori" class="team-photo">
                <div class="team-info">
                    <div class="team-name">Dr Anne Cori</div>
                    <div class="team-role">Imperial College London</div>
                    <p class="team-bio">Senior Lecturer specialising in real-time outbreak analysis and epidemiological parameters. Lead author of <a href="https://academic.oup.com/aje/article/178/9/1505/89262" target="_blank">EpiEstim</a> and co-author of <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003457" target="_blank">outbreaker</a>. Develops statistical methods for outbreak reconstruction and rapid transmissibility assessment.</p>
                </div>
            </div>
            <div class="team-card reveal" style="transition-delay: 0.3s;">
                <img src="images/shaun.jpg" alt="Dr Shaun Truelove" class="team-photo">
                <div class="team-info">
                    <div class="team-name">Dr Shaun Truelove</div>
                    <div class="team-role">Johns Hopkins University</div>
                    <p class="team-bio">Associate Professor focused on infectious disease dynamics and modelling for public health response and policy (COVID-19, influenza, vaccine-preventable diseases). Co-leads the <a href="https://scenariomodelinghub.org/" target="_blank">US Scenario Modeling Hubs</a> and <a href="https://insightnet.us/centers/accidda/" target="_blank">ACCIDA</a>, a consortium producing epidemic scenario projections and forecasts.</p>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- ========== CONTACT ========== -->
<section id="contact" class="section-padding">
    <div class="container">
        <div class="contact-grid">
            <div class="reveal">
                <span class="section-tag">05 — Contact</span>
                <h2 class="contact-heading">Let's Work<br>Together</h2>
                <p class="contact-sub">We are actively seeking collaborations and funding. Please reach out!</p>
                <a href="https://github.com/CyGei" target="_blank" style="display:inline-flex; align-items:center; gap:8px; color:var(--text-secondary); font-family:var(--mono); font-size:0.8rem; transition:color 0.3s;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
                    github.com/CyGei
                </a>
            </div>
            <div class="reveal" style="transition-delay: 0.2s;">
                <form class="contact-form" method="POST" action="https://formspree.io/f/maqdqzqw">
                    <label for="name">Name</label>
                    <input type="text" name="name" id="name" required>
                    <label for="email">Email</label>
                    <input type="email" name="email" id="email" required>
                    <label for="message">Message</label>
                    <textarea name="message" id="message" rows="5" required></textarea>
                    <div class="form-buttons">
                        <button type="submit" class="btn-primary">Send Message</button>
                        <button type="reset" class="btn-secondary">Reset</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</section>

<!-- ========== FOOTER ========== -->
<footer>
    <div class="container">
        <div class="footer-inner">
            <div class="footer-logo">Noso<span>Track</span></div>
            <ul class="footer-links">
                <li><a href="#about">About</a></li>
                <li><a href="#research">Research</a></li>
                <li><a href="#team">Team</a></li>
                <li><a href="#contact">Contact</a></li>
                <li><a href="https://github.com/CyGei" target="_blank">GitHub</a></li>
            </ul>
            <div class="footer-copy">&copy; Cyril Geismar.</div>
        </div>
    </div>
</footer>

<!-- ========== SCRIPTS ========== -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ==========================================
// BACKGROUND NETWORK ANIMATION (Canvas 2D)
// ==========================================
(function() {
    const canvas = document.getElementById('network-canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    let particles = [];

    const particleCount = 120;
    const connectionDistance = 140;
    const particleSpeed = 0.4;
    const infectionChance = 0.015;
    const recoveryTime = 700;

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    class Particle {
        constructor() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.vx = (Math.random() - 0.5) * particleSpeed;
            this.vy = (Math.random() - 0.5) * particleSpeed;
            this.size = Math.random() * 1.5 + 0.5;
            this.isInfected = false;
            this.infectionTimer = 0;
        }
        infect() {
            if (!this.isInfected) {
                this.isInfected = true;
                this.infectionTimer = recoveryTime;
            }
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            if (this.x < 0 || this.x > width) this.vx *= -1;
            if (this.y < 0 || this.y > height) this.vy *= -1;
            if (this.isInfected) {
                this.infectionTimer--;
                if (this.infectionTimer <= 0) this.isInfected = false;
            }
        }
        draw() {
            ctx.fillStyle = this.isInfected ? 'rgba(230, 57, 70, 0.8)' : 'rgba(150, 150, 150, 0.4)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            if (this.isInfected) {
                ctx.fillStyle = 'rgba(230, 57, 70, 0.15)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size + 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function initParticles() {
        particles = [];
        for (let i = 0; i < particleCount; i++) {
            const p = new Particle();
            if (Math.random() < 0.04) p.infect();
            particles.push(p);
        }
    }
    initParticles();

    function animate() {
        ctx.clearRect(0, 0, width, height);
        if (!particles.some(p => p.isInfected)) {
            particles[Math.floor(Math.random() * particles.length)].infect();
        }
        for (let i = 0; i < particles.length; i++) {
            particles[i].update();
            particles[i].draw();
            for (let j = i + 1; j < particles.length; j++) {
                const dx = particles[i].x - particles[j].x;
                const dy = particles[i].y - particles[j].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < connectionDistance) {
                    if (particles[i].isInfected && !particles[j].isInfected && Math.random() < infectionChance) particles[j].infect();
                    else if (!particles[i].isInfected && particles[j].isInfected && Math.random() < infectionChance) particles[i].infect();
                    const opacity = 1 - (dist / connectionDistance);
                    if (particles[i].isInfected || particles[j].isInfected) {
                        ctx.strokeStyle = `rgba(230, 57, 70, ${opacity * 0.4})`;
                    } else {
                        ctx.strokeStyle = `rgba(150, 150, 150, ${opacity * 0.12})`;
                    }
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(particles[i].x, particles[i].y);
                    ctx.lineTo(particles[j].x, particles[j].y);
                    ctx.stroke();
                }
            }
        }
        requestAnimationFrame(animate);
    }
    animate();
})();

// ==========================================
// NAV TOGGLE
// ==========================================
document.getElementById('navToggle').addEventListener('click', function() {
    document.getElementById('navLinks').classList.toggle('open');
});
document.querySelectorAll('.nav-links a').forEach(a => {
    a.addEventListener('click', () => document.getElementById('navLinks').classList.remove('open'));
});

// ==========================================
// SCROLL REVEAL
// ==========================================
const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.classList.add('visible');
        }
    });
}, { threshold: 0.1, rootMargin: '0px 0px -40px 0px' });
document.querySelectorAll('.reveal').forEach(el => observer.observe(el));

// ==========================================
// PIPELINE ANIMATION (Canvas 2D)
// ==========================================
(function() {
    const canvas = document.getElementById('pipeline-canvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    const ACCENT = '#e63946';
    const ACCENT_DIM = 'rgba(230, 57, 70, 0.15)';
    const DIM = '#333333';
    const ACTIVE = '#f0f0f0';
    const BG = '#111111';
    const MONO = '"JetBrains Mono", monospace';

    const steps = [
        { title: 'DNA Sequencing',     desc: 'Pathogen genomes are sequenced',   draw: drawDNA },
        { title: 'Contact Tracing',    desc: 'Bluetooth proximity detection',     draw: drawContact },
        { title: 'Health Records',     desc: 'Clinical data from hospital EHR',   draw: drawEHR },
        { title: 'Anonymisation',      desc: 'Identifiers masked & encrypted',    draw: drawAnon },
        { title: 'Data Merging',       desc: 'Streams converge into NosoTrack',   draw: drawMerge },
        { title: 'Transmission Tree',  desc: 'Infer who infected whom',           draw: drawTree },
        { title: 'Warning System',     desc: 'Alerts dispatched to IPC teams',    draw: drawAlert },
    ];

    let W, H, vertical, dpr;
    let activeStep = -1, stepTimer = 0, particleT = -1;
    const STEP_DUR = 130;
    const P_SPEED = 0.022;
    let descFade = new Array(steps.length).fill(0);
    let stepLit = new Array(steps.length).fill(0);

    function resize() {
        dpr = Math.min(window.devicePixelRatio, 2);
        const r = canvas.getBoundingClientRect();
        W = r.width; H = r.height;
        canvas.width = W * dpr; canvas.height = H * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        vertical = W < 600;
    }
    window.addEventListener('resize', resize);
    resize();

    function pos(i) {
        if (vertical) {
            const m = 70, sp = (H - m * 2) / (steps.length - 1);
            return { x: W / 2, y: m + i * sp };
        }
        const m = 80, sp = (W - m * 2) / (steps.length - 1);
        return { x: m + i * sp, y: H * 0.42 };
    }

    function ease(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }

    // === ICON FUNCTIONS ===
    function drawDNA(cx, cy, s, col) {
        ctx.strokeStyle = col; ctx.lineWidth = 2;
        const amp = s * 0.4;
        for (let strand = 0; strand < 2; strand++) {
            const sign = strand === 0 ? 1 : -1;
            ctx.beginPath();
            for (let i = 0; i <= 24; i++) {
                const t = i / 24;
                const y = cy - s + t * s * 2;
                const x = cx + Math.sin(t * Math.PI * 3) * amp * sign;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        ctx.lineWidth = 1; ctx.globalAlpha = 0.5;
        for (let i = 0; i < 4; i++) {
            const t = (i + 0.25) / 4;
            const y = cy - s + t * s * 2;
            const x1 = cx + Math.sin(t * Math.PI * 3) * amp;
            const x2 = cx - Math.sin(t * Math.PI * 3) * amp;
            ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x2, y); ctx.stroke();
        }
        ctx.globalAlpha = 1;
    }

    function drawContact(cx, cy, s, col) {
        ctx.strokeStyle = col; ctx.fillStyle = col; ctx.lineWidth = 1.5;
        // Central device
        const dw = s * 0.25, dh = s * 0.45;
        ctx.strokeRect(cx - dw, cy - dh, dw * 2, dh * 2);
        // Small dot in device center
        ctx.beginPath(); ctx.arc(cx, cy, 2, 0, Math.PI * 2); ctx.fill();
        // People dots
        const angles = [-1.2, -0.4, 0.4, 1.2, Math.PI - 0.4, Math.PI + 0.4];
        angles.forEach(a => {
            const px = cx + Math.cos(a) * s * 0.85;
            const py = cy + Math.sin(a) * s * 0.55;
            ctx.beginPath(); ctx.arc(px, py, 2.5, 0, Math.PI * 2); ctx.fill();
        });
        // Signal arcs
        ctx.globalAlpha = 0.4;
        for (let r = 1; r <= 2; r++) {
            ctx.beginPath();
            ctx.arc(cx, cy, s * 0.35 * r, -0.8, 0.8);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
    }

    function drawEHR(cx, cy, s, col) {
        ctx.strokeStyle = col; ctx.lineWidth = 1.5;
        const w = s * 0.65, h = s * 1.1;
        // Document outline
        ctx.beginPath();
        ctx.moveTo(cx - w/2, cy - h/2);
        ctx.lineTo(cx + w/2 - 6, cy - h/2);
        ctx.lineTo(cx + w/2, cy - h/2 + 6);
        ctx.lineTo(cx + w/2, cy + h/2);
        ctx.lineTo(cx - w/2, cy + h/2);
        ctx.closePath(); ctx.stroke();
        // Dog ear
        ctx.beginPath();
        ctx.moveTo(cx + w/2 - 6, cy - h/2);
        ctx.lineTo(cx + w/2 - 6, cy - h/2 + 6);
        ctx.lineTo(cx + w/2, cy - h/2 + 6);
        ctx.stroke();
        // Data lines
        ctx.globalAlpha = 0.6;
        for (let i = 0; i < 4; i++) {
            const y = cy - h/2 + h * 0.25 + i * h * 0.17;
            const lw = i === 0 ? w * 0.7 : w * 0.5 + (i % 2) * w * 0.1;
            ctx.beginPath(); ctx.moveTo(cx - w/2 + 6, y); ctx.lineTo(cx - w/2 + 6 + lw, y); ctx.stroke();
        }
        ctx.globalAlpha = 1;
    }

    function drawAnon(cx, cy, s, col) {
        ctx.strokeStyle = col; ctx.fillStyle = col; ctx.lineWidth = 1.5;
        const bw = s * 0.55, bh = s * 0.5;
        // Lock body
        ctx.strokeRect(cx - bw/2, cy - bh/6, bw, bh);
        // Shackle
        ctx.beginPath();
        ctx.arc(cx, cy - bh/6, bw * 0.32, Math.PI, 0);
        ctx.stroke();
        // Keyhole
        ctx.beginPath(); ctx.arc(cx, cy + bh * 0.15, 3, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(cx, cy + bh * 0.15 + 3); ctx.lineTo(cx, cy + bh * 0.15 + 8); ctx.stroke();
    }

    function drawMerge(cx, cy, s, col) {
        ctx.strokeStyle = col; ctx.lineWidth = 2;
        const offsets = [-s * 0.55, 0, s * 0.55];
        offsets.forEach(yOff => {
            ctx.beginPath();
            ctx.moveTo(cx - s * 0.9, cy + yOff);
            ctx.bezierCurveTo(cx - s * 0.2, cy + yOff, cx - s * 0.2, cy, cx + s * 0.15, cy);
            ctx.stroke();
        });
        // Arrow
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.moveTo(cx + s * 0.15, cy - 5);
        ctx.lineTo(cx + s * 0.45, cy);
        ctx.lineTo(cx + s * 0.15, cy + 5);
        ctx.closePath(); ctx.fill();
        // NosoTrack box
        ctx.strokeRect(cx + s * 0.5, cy - 8, s * 0.4, 16);
        ctx.font = `500 7px ${MONO}`;
        ctx.fillStyle = col; ctx.textAlign = 'center';
        ctx.fillText('NT', cx + s * 0.7, cy + 3);
    }

    function drawTree(cx, cy, s, col) {
        ctx.strokeStyle = col; ctx.fillStyle = col; ctx.lineWidth = 1.5;
        // Root
        ctx.beginPath(); ctx.arc(cx, cy - s * 0.65, 4, 0, Math.PI * 2); ctx.fill();
        // Main branches
        ctx.beginPath(); ctx.moveTo(cx, cy - s * 0.65); ctx.lineTo(cx - s * 0.45, cy - s * 0.05); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx, cy - s * 0.65); ctx.lineTo(cx + s * 0.45, cy - s * 0.05); ctx.stroke();
        // L2 nodes
        ctx.beginPath(); ctx.arc(cx - s * 0.45, cy - s * 0.05, 3, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + s * 0.45, cy - s * 0.05, 3, 0, Math.PI * 2); ctx.fill();
        // Sub-branches
        const subs = [[-0.45, -0.2], [-0.45, 0.2], [0.45, -0.2], [0.45, 0.2]];
        subs.forEach(([px, dx]) => {
            ctx.beginPath(); ctx.moveTo(cx + px * s, cy - s * 0.05);
            ctx.lineTo(cx + (px + dx) * s, cy + s * 0.5); ctx.stroke();
            ctx.beginPath(); ctx.arc(cx + (px + dx) * s, cy + s * 0.5, 2.5, 0, Math.PI * 2); ctx.fill();
        });
    }

    function drawAlert(cx, cy, s, col) {
        ctx.strokeStyle = col; ctx.fillStyle = col; ctx.lineWidth = 1.5;
        const w = s * 0.85, h = s * 0.55;
        // Envelope body
        ctx.strokeRect(cx - w/2, cy - h/2 + 4, w, h);
        // Flap
        ctx.beginPath();
        ctx.moveTo(cx - w/2, cy - h/2 + 4);
        ctx.lineTo(cx, cy + 6);
        ctx.lineTo(cx + w/2, cy - h/2 + 4);
        ctx.stroke();
        // Notification badge
        ctx.beginPath(); ctx.arc(cx + w/2 - 2, cy - h/2, 5, 0, Math.PI * 2); ctx.fill();
        // Exclamation in badge
        ctx.fillStyle = BG;
        ctx.font = `700 7px ${MONO}`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('!', cx + w/2 - 2, cy - h/2);
        ctx.textBaseline = 'alphabetic';
    }

    // === ANIMATION LOOP ===
    function animate() {
        requestAnimationFrame(animate);
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);

        stepTimer++;
        if (stepTimer >= STEP_DUR) {
            stepTimer = 0;
            activeStep++;
            if (activeStep >= steps.length) {
                activeStep = 0;
                stepLit.fill(0); descFade.fill(0);
            }
            stepLit[activeStep] = 1;
            particleT = 0;
        }

        // Fade descriptions
        for (let i = 0; i < steps.length; i++) {
            descFade[i] = i <= activeStep
                ? Math.min(1, descFade[i] + 0.04)
                : Math.max(0, descFade[i] - 0.06);
        }

        // Connecting lines
        for (let i = 0; i < steps.length - 1; i++) {
            const a = pos(i), b = pos(i + 1);
            const lit = i < activeStep;
            ctx.strokeStyle = lit ? ACCENT : DIM;
            ctx.lineWidth = lit ? 2 : 1;
            ctx.globalAlpha = lit ? 0.5 : 0.2;

            // Dashed line style for unlit
            if (!lit) { ctx.setLineDash([4, 4]); } else { ctx.setLineDash([]); }
            ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;

            // Small arrow at midpoint for lit lines
            if (lit) {
                const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
                const ang = Math.atan2(b.y - a.y, b.x - a.x);
                ctx.fillStyle = ACCENT; ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(mx + Math.cos(ang) * 6, my + Math.sin(ang) * 6);
                ctx.lineTo(mx + Math.cos(ang + 2.5) * 5, my + Math.sin(ang + 2.5) * 5);
                ctx.lineTo(mx + Math.cos(ang - 2.5) * 5, my + Math.sin(ang - 2.5) * 5);
                ctx.closePath(); ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Traveling particle
        if (particleT >= 0 && particleT < 1 && activeStep < steps.length - 1) {
            particleT += P_SPEED;
            const a = pos(activeStep), b = pos(activeStep + 1);
            const t = ease(Math.min(particleT, 1));
            const px = a.x + (b.x - a.x) * t;
            const py = a.y + (b.y - a.y) * t;
            const grad = ctx.createRadialGradient(px, py, 0, px, py, 14);
            grad.addColorStop(0, ACCENT);
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(px, py, 14, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(px, py, 2.5, 0, Math.PI * 2); ctx.fill();
        }

        // Draw steps
        const iconSize = vertical ? 18 : 22;
        for (let i = 0; i < steps.length; i++) {
            const p = pos(i), step = steps[i];
            const lit = stepLit[i] > 0;
            const col = lit ? ACTIVE : DIM;

            // Background circle
            ctx.fillStyle = lit ? ACCENT_DIM : 'rgba(255,255,255,0.03)';
            ctx.beginPath(); ctx.arc(p.x, p.y, iconSize + 12, 0, Math.PI * 2); ctx.fill();

            // Accent ring pulse for active
            if (lit) {
                ctx.strokeStyle = ACCENT;
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.4 + Math.sin(stepTimer * 0.06) * 0.15;
                ctx.beginPath(); ctx.arc(p.x, p.y, iconSize + 12, 0, Math.PI * 2); ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Icon
            step.draw(p.x, p.y, iconSize, col);

            // Step number
            ctx.font = `500 10px ${MONO}`;
            ctx.fillStyle = lit ? ACCENT : DIM;
            ctx.textAlign = 'center';
            ctx.fillText(`0${i + 1}`, p.x, p.y - iconSize - 20);

            // Title
            ctx.font = `600 ${vertical ? 10 : 11}px ${MONO}`;
            ctx.fillStyle = lit ? ACTIVE : DIM;
            const ty = p.y + iconSize + 26;
            ctx.fillText(step.title, p.x, ty);

            // Description (fades in)
            if (descFade[i] > 0.01) {
                ctx.globalAlpha = descFade[i];
                ctx.font = `300 ${vertical ? 9 : 10}px ${MONO}`;
                ctx.fillStyle = '#888';
                ctx.fillText(step.desc, p.x, ty + 16);
                ctx.globalAlpha = 1;
            }
        }
    }

    // Start after a short delay to ensure font is loaded
    setTimeout(() => { resize(); requestAnimationFrame(animate); }, 100);
})();

// ==========================================
// 3D TRANSMISSION NETWORK (Three.js)
// ==========================================
(function() {
    const container = document.getElementById('three-container');
    const tooltip = document.getElementById('vizTooltip');
    if (!container) return;

    const W = container.clientWidth;
    const H = container.clientHeight || 600;

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a);
    scene.fog = new THREE.FogExp2(0x0a0a0a, 0.0012);

    const camera = new THREE.PerspectiveCamera(55, W / H, 1, 2000);
    camera.position.set(0, 90, 420);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(W, H);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 0.6, 800);
    pointLight.position.set(100, 200, 200);
    scene.add(pointLight);

    // Colors
    const COLORS = {
        healthy: 0x555555,
        infected: 0xe63946,
        wardA: 0x6496ff,
        wardB: 0xff9664,
        wardC: 0x96ff64,
        edge: 0x333333,
        edgeInfected: 0xe63946,
        particle: 0xe63946,
    };

    // Node data
    const nodeData = [
        { id: 1, label: 'P0', ward: 'A', type: 'patient' },
        { id: 2, label: 'S1', ward: 'A', type: 'staff' },
        { id: 3, label: 'S2', ward: 'B', type: 'staff' },
        { id: 4, label: 'P3', ward: 'A', type: 'patient' },
        { id: 5, label: 'P4', ward: 'A', type: 'patient' },
        { id: 6, label: 'P5', ward: 'B', type: 'patient' },
        { id: 7, label: 'P6', ward: 'B', type: 'patient' },
        { id: 8, label: 'P7', ward: 'C', type: 'patient' },
        { id: 10, label: 'S3', ward: 'B', type: 'staff' },
        { id: 9, label: 'P2', ward: 'A', type: 'patient' },
        { id: 11, label: 'S4', ward: 'A', type: 'staff' },
        { id: 12, label: 'P10', ward: 'B', type: 'patient' },
        { id: 13, label: 'S5', ward: 'B', type: 'staff' },
        { id: 14, label: 'P12', ward: 'B', type: 'patient' },
        { id: 15, label: 'P13', ward: 'B', type: 'patient' },
        { id: 16, label: 'S6', ward: 'C', type: 'staff' },
        { id: 18, label: 'S7', ward: 'C', type: 'staff' },
        { id: 19, label: 'P17', ward: 'C', type: 'patient' },
        { id: 20, label: 'P18', ward: 'C', type: 'patient' },
        { id: 21, label: 'S8', ward: 'A', type: 'staff' },
        { id: 17, label: 'P15', ward: 'C', type: 'patient' },
        { id: 22, label: 'P20', ward: 'A', type: 'patient' },
        { id: 23, label: 'P21', ward: 'A', type: 'patient' },
    ];

    const edgeData = [
        { from: 1, to: 2 }, { from: 1, to: 3 },
        { from: 2, to: 4 }, { from: 2, to: 5 },
        { from: 3, to: 6 }, { from: 3, to: 7 }, { from: 3, to: 8 },
        { from: 6, to: 10 },
        { from: 10, to: 9 }, { from: 10, to: 11 }, { from: 10, to: 12 },
        { from: 10, to: 13 }, { from: 10, to: 14 }, { from: 10, to: 15 },
        { from: 10, to: 16 }, { from: 10, to: 18 },
        { from: 18, to: 19 }, { from: 18, to: 20 },
        { from: 9, to: 21 },
        { from: 21, to: 22 }, { from: 21, to: 23 },
        { from: 16, to: 17 },
    ];

    // Force-directed layout
    const nodeMap = {};
    const wardCenters = { A: { x: -180, z: -80 }, B: { x: 0, z: 90 }, C: { x: 180, z: -40 } };

    nodeData.forEach(n => {
        const wc = wardCenters[n.ward];
        nodeMap[n.id] = {
            ...n,
            x: wc.x + (Math.random() - 0.5) * 100,
            y: (Math.random() - 0.5) * 80,
            z: wc.z + (Math.random() - 0.5) * 100,
            vx: 0, vy: 0, vz: 0,
            infected: false,
            mesh: null,
            glow: null,
        };
    });

    // Run force simulation
    function simulateForces(iterations) {
        const nodes = Object.values(nodeMap);
        for (let iter = 0; iter < iterations; iter++) {
            // Repulsion
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[i].x - nodes[j].x;
                    const dy = nodes[i].y - nodes[j].y;
                    const dz = nodes[i].z - nodes[j].z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.1;
                    const force = 800 / (dist * dist);
                    const fx = (dx/dist) * force;
                    const fy = (dy/dist) * force;
                    const fz = (dz/dist) * force;
                    nodes[i].vx += fx; nodes[i].vy += fy; nodes[i].vz += fz;
                    nodes[j].vx -= fx; nodes[j].vy -= fy; nodes[j].vz -= fz;
                }
            }
            // Attraction along edges
            edgeData.forEach(e => {
                const a = nodeMap[e.from], b = nodeMap[e.to];
                const dx = b.x - a.x, dy = b.y - a.y, dz = b.z - a.z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.1;
                const force = (dist - 50) * 0.04;
                const fx = (dx/dist)*force, fy = (dy/dist)*force, fz = (dz/dist)*force;
                a.vx += fx; a.vy += fy; a.vz += fz;
                b.vx -= fx; b.vy -= fy; b.vz -= fz;
            });
            // Ward gravity
            nodes.forEach(n => {
                const wc = wardCenters[n.ward];
                n.vx += (wc.x - n.x) * 0.025;
                n.vz += (wc.z - n.z) * 0.025;
                n.vy += (0 - n.y) * 0.012;
            });
            // Damping & update
            const damping = 0.85;
            nodes.forEach(n => {
                n.vx *= damping; n.vy *= damping; n.vz *= damping;
                n.x += n.vx; n.y += n.vy; n.z += n.vz;
            });
        }
    }
    simulateForces(200);

    // Ward ground planes & labels
    const wardConfig = {
        A: { color: COLORS.wardA, radius: 80 },
        B: { color: COLORS.wardB, radius: 90 },
        C: { color: COLORS.wardC, radius: 75 },
    };
    Object.entries(wardCenters).forEach(([ward, center]) => {
        const cfg = wardConfig[ward];
        // Semi-transparent disc
        const discGeo = new THREE.CircleGeometry(cfg.radius, 64);
        const discMat = new THREE.MeshBasicMaterial({
            color: cfg.color, transparent: true, opacity: 0.07,
            side: THREE.DoubleSide, depthWrite: false,
        });
        const disc = new THREE.Mesh(discGeo, discMat);
        disc.rotation.x = -Math.PI / 2;
        disc.position.set(center.x, -45, center.z);
        scene.add(disc);

        // Ring border
        const ringGeo = new THREE.RingGeometry(cfg.radius - 1.5, cfg.radius, 64);
        const ringMat = new THREE.MeshBasicMaterial({
            color: cfg.color, transparent: true, opacity: 0.15,
            side: THREE.DoubleSide, depthWrite: false,
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = -Math.PI / 2;
        ring.position.set(center.x, -44.5, center.z);
        scene.add(ring);
    });

    // Ward label sprites
    function createWardLabel(text, color) {
        const c = document.createElement('canvas');
        c.width = 256; c.height = 64;
        const cx = c.getContext('2d');
        cx.font = '500 28px "JetBrains Mono", monospace';
        cx.textAlign = 'center'; cx.textBaseline = 'middle';
        cx.fillStyle = '#' + new THREE.Color(color).getHexString();
        cx.globalAlpha = 0.7;
        cx.fillText(text, 128, 32);
        const texture = new THREE.CanvasTexture(c);
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthWrite: false });
        const sprite = new THREE.Sprite(mat);
        sprite.scale.set(80, 20, 1);
        return sprite;
    }
    Object.entries(wardCenters).forEach(([ward, center]) => {
        const label = createWardLabel('Ward ' + ward, wardConfig[ward].color);
        label.position.set(center.x, 55, center.z);
        scene.add(label);
    });

    // Create 3D nodes
    const nodeMeshes = [];
    const glowMeshes = [];
    Object.values(nodeMap).forEach(n => {
        const wardColor = COLORS['ward' + n.ward];
        const isStaff = n.type === 'staff';
        const size = n.id === 10 ? 7 : (isStaff ? 4.5 : 5);

        let geometry;
        if (isStaff) {
            geometry = new THREE.OctahedronGeometry(size, 0);
        } else {
            geometry = new THREE.SphereGeometry(size, 16, 16);
        }

        const material = new THREE.MeshPhongMaterial({
            color: COLORS.healthy,
            emissive: 0x000000,
            shininess: 60,
            transparent: true,
            opacity: 0.9,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(n.x, n.y, n.z);
        mesh.userData = { nodeId: n.id, label: n.label, ward: n.ward, type: n.type, wardColor };
        scene.add(mesh);
        n.mesh = mesh;
        nodeMeshes.push(mesh);

        // Glow sphere
        const glowGeo = new THREE.SphereGeometry(size * 2.5, 12, 12);
        const glowMat = new THREE.MeshBasicMaterial({
            color: COLORS.infected,
            transparent: true,
            opacity: 0,
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        glow.position.copy(mesh.position);
        scene.add(glow);
        n.glow = glow;
        glowMeshes.push(glow);
    });

    // Create edges
    const edgeMeshes = [];
    edgeData.forEach(e => {
        const a = nodeMap[e.from], b = nodeMap[e.to];
        const points = [new THREE.Vector3(a.x, a.y, a.z), new THREE.Vector3(b.x, b.y, b.z)];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: COLORS.edge, transparent: true, opacity: 0.25 });
        const line = new THREE.Line(geometry, material);
        line.userData = { from: e.from, to: e.to };
        scene.add(line);
        edgeMeshes.push(line);
    });

    // Transmission particles
    const transmissionParticles = [];
    function createTransmissionParticle(fromId, toId) {
        const a = nodeMap[fromId], b = nodeMap[toId];
        const geo = new THREE.SphereGeometry(2, 8, 8);
        const mat = new THREE.MeshBasicMaterial({ color: COLORS.particle, transparent: true, opacity: 1 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(a.x, a.y, a.z);
        scene.add(mesh);

        // Trail
        const trailPositions = [];
        for (let i = 0; i < 8; i++) trailPositions.push(a.x, a.y, a.z);
        const trailGeo = new THREE.BufferGeometry();
        trailGeo.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));
        const trailMat = new THREE.LineBasicMaterial({ color: COLORS.particle, transparent: true, opacity: 0.3 });
        const trail = new THREE.Line(trailGeo, trailMat);
        scene.add(trail);

        transmissionParticles.push({
            mesh, trail, trailGeo,
            from: new THREE.Vector3(a.x, a.y, a.z),
            to: new THREE.Vector3(b.x, b.y, b.z),
            progress: 0,
            targetId: toId,
            speed: 0.012 + Math.random() * 0.008,
            trailPositions: trailPositions.slice(),
        });
    }

    // Infection simulation
    const infectedSet = new Set();
    let simQueue = [];
    let simTimer = 0;
    const SIM_INTERVAL = 80;

    function resetSimulation() {
        infectedSet.clear();
        transmissionParticles.forEach(p => { scene.remove(p.mesh); scene.remove(p.trail); });
        transmissionParticles.length = 0;

        Object.values(nodeMap).forEach(n => {
            n.infected = false;
            n.mesh.material.color.setHex(COLORS.healthy);
            n.mesh.material.emissive.setHex(0x000000);
            n.glow.material.opacity = 0;
        });
        edgeMeshes.forEach(e => {
            e.material.color.setHex(COLORS.edge);
            e.material.opacity = 0.25;
        });

        // Build infection order from edges (BFS)
        simQueue = [];
        const visited = new Set();
        const queue = [1]; // Start from P0
        visited.add(1);
        infectNode(1);

        while (queue.length > 0) {
            const current = queue.shift();
            const downstream = edgeData.filter(e => e.from === current && !visited.has(e.to));
            // Superspreader (id=10) infects all at once
            if (current === 10) {
                downstream.forEach(e => {
                    visited.add(e.to);
                    simQueue.push({ from: current, to: e.to });
                    queue.push(e.to);
                });
            } else {
                downstream.forEach(e => {
                    visited.add(e.to);
                    simQueue.push({ from: current, to: e.to });
                    queue.push(e.to);
                });
            }
        }
    }

    function infectNode(id) {
        const n = nodeMap[id];
        if (!n) return;
        n.infected = true;
        infectedSet.add(id);
        n.mesh.material.color.setHex(COLORS.infected);
        n.mesh.material.emissive.setHex(0x661118);
    }

    resetSimulation();

    // Raycaster for interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredNode = null;

    container.addEventListener('mousemove', (event) => {
        const rect = container.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(nodeMeshes);

        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (hoveredNode !== obj) {
                if (hoveredNode) resetHighlight();
                hoveredNode = obj;
                highlightConnections(obj.userData.nodeId);
                tooltip.style.display = 'block';
                tooltip.textContent = `${obj.userData.label} (${obj.userData.type}) — Ward ${obj.userData.ward}`;
            }
            tooltip.style.left = (event.clientX - container.getBoundingClientRect().left + 12) + 'px';
            tooltip.style.top = (event.clientY - container.getBoundingClientRect().top - 12) + 'px';
            container.style.cursor = 'pointer';
        } else {
            if (hoveredNode) {
                resetHighlight();
                hoveredNode = null;
            }
            tooltip.style.display = 'none';
            container.style.cursor = 'default';
        }
    });

    container.addEventListener('mouseleave', () => {
        if (hoveredNode) { resetHighlight(); hoveredNode = null; }
        tooltip.style.display = 'none';
    });

    function highlightConnections(nodeId) {
        // Dim all
        nodeMeshes.forEach(m => { m.material.opacity = 0.2; });
        edgeMeshes.forEach(e => { e.material.opacity = 0.05; });
        // Highlight connected
        const connectedIds = new Set([nodeId]);
        edgeData.forEach(e => {
            if (e.from === nodeId) connectedIds.add(e.to);
            if (e.to === nodeId) connectedIds.add(e.from);
        });
        nodeMeshes.forEach(m => {
            if (connectedIds.has(m.userData.nodeId)) m.material.opacity = 1;
        });
        edgeMeshes.forEach(e => {
            if (e.userData.from === nodeId || e.userData.to === nodeId) {
                e.material.opacity = 0.8;
                e.material.color.setHex(0xffffff);
            }
        });
    }

    function resetHighlight() {
        nodeMeshes.forEach(m => { m.material.opacity = 0.9; });
        edgeMeshes.forEach(e => {
            const fromInfected = nodeMap[e.userData.from].infected;
            const toInfected = nodeMap[e.userData.to].infected;
            if (fromInfected && toInfected) {
                e.material.color.setHex(COLORS.edgeInfected);
                e.material.opacity = 0.5;
            } else {
                e.material.color.setHex(COLORS.edge);
                e.material.opacity = 0.25;
            }
        });
    }

    // Animation loop
    let time = 0;
    let orbitAngle = 0;

    function animateViz() {
        requestAnimationFrame(animateViz);
        time++;
        orbitAngle += 0.002;

        // Camera orbit
        camera.position.x = Math.sin(orbitAngle) * 420;
        camera.position.z = Math.cos(orbitAngle) * 420;
        camera.position.y = 90 + Math.sin(orbitAngle * 0.5) * 40;
        camera.lookAt(0, 0, 0);

        // Node breathing
        nodeMeshes.forEach(m => {
            const s = 1 + Math.sin(time * 0.03 + m.userData.nodeId) * 0.05;
            m.scale.set(s, s, s);
        });

        // Glow animation for infected
        glowMeshes.forEach((g, i) => {
            const n = Object.values(nodeMap)[i];
            if (n.infected) {
                g.material.opacity = 0.12 + Math.sin(time * 0.05 + n.id) * 0.06;
                g.position.copy(n.mesh.position);
            } else {
                g.material.opacity = 0;
            }
        });

        // Transmission simulation
        simTimer++;
        if (simTimer > SIM_INTERVAL && simQueue.length > 0) {
            simTimer = 0;
            // Check if the current front has a superspreader
            const next = simQueue[0];
            if (next.from === 10) {
                // Fire all superspreader edges at once
                const batch = [];
                while (simQueue.length > 0 && simQueue[0].from === 10) {
                    batch.push(simQueue.shift());
                }
                batch.forEach(t => createTransmissionParticle(t.from, t.to));
            } else {
                simQueue.shift();
                createTransmissionParticle(next.from, next.to);
            }
        }

        // All done? Reset after pause
        if (simQueue.length === 0 && transmissionParticles.length === 0 && infectedSet.size > 1) {
            simTimer = -200; // pause
            if (simTimer === -200) {
                setTimeout(() => resetSimulation(), 4000);
                simQueue.push({}); // prevent re-trigger
            }
        }

        // Update transmission particles
        for (let i = transmissionParticles.length - 1; i >= 0; i--) {
            const p = transmissionParticles[i];
            p.progress += p.speed;

            if (p.progress >= 1) {
                infectNode(p.targetId);
                // Update edge color
                edgeMeshes.forEach(e => {
                    if ((e.userData.from === nodeMap[p.targetId] || e.userData.to === nodeMap[p.targetId])) {
                        // check both directions
                    }
                });
                edgeData.forEach((ed, idx) => {
                    if ((ed.from === p.targetId || ed.to === p.targetId) &&
                        nodeMap[ed.from].infected && nodeMap[ed.to].infected) {
                        edgeMeshes[idx].material.color.setHex(COLORS.edgeInfected);
                        edgeMeshes[idx].material.opacity = 0.5;
                    }
                });

                scene.remove(p.mesh);
                scene.remove(p.trail);
                transmissionParticles.splice(i, 1);
                continue;
            }

            const pos = new THREE.Vector3().lerpVectors(p.from, p.to, p.progress);
            // Arc
            pos.y += Math.sin(p.progress * Math.PI) * 15;
            p.mesh.position.copy(pos);
            p.mesh.material.opacity = 1 - p.progress * 0.3;

            // Update trail
            const positions = p.trailGeo.attributes.position.array;
            for (let t = positions.length - 3; t >= 3; t -= 3) {
                positions[t] = positions[t-3];
                positions[t+1] = positions[t-2];
                positions[t+2] = positions[t-1];
            }
            positions[0] = pos.x; positions[1] = pos.y; positions[2] = pos.z;
            p.trailGeo.attributes.position.needsUpdate = true;
        }

        renderer.render(scene, camera);
    }
    animateViz();

    // Resize handling
    window.addEventListener('resize', () => {
        const w = container.clientWidth;
        const h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
    });
})();
</script>

</body>
</html>
